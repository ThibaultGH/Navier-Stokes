<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<title>Eigen-unsupported: Eigen::internal Namespace Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { init_search(); });
</script>
<link href="doxygen.css"   rel="stylesheet" type="text/css" />
<link href="eigendoxy.css" rel="stylesheet" type="text/css">
<!--  -->
<script type="text/javascript" src="eigen_navtree_hacks.js"></script>
<!-- <script type="text/javascript"> -->
<!-- </script> -->
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<!-- <a name="top"></a> -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="Eigen_Silly_Professor_64x64.png"/></td>
  <td style="padding-left: 0.5em;">
   <div id="projectname"><a href="http://eigen.tuxfamily.org">Eigen-unsupported</a>
   &#160;<span id="projectnumber">3.3.4</span>
   </div>
  </td>
   <td>        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
</td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('namespaceEigen_1_1internal.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">Eigen::internal Namespace Reference<div class="ingroups"><a class="el" href="group__AlignedVector3__Module.html">Aligned vector3 module</a></div></div>  </div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ga1c2f99746877fd46158af4a6b7dce2f9"><td class="memTemplParams" colspan="2">template&lt;typename TMatrix , typename CMatrix , typename VectorX , typename VectorB , typename VectorF &gt; </td></tr>
<tr class="memitem:ga1c2f99746877fd46158af4a6b7dce2f9"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__IterativeSolvers__Module.html#ga1c2f99746877fd46158af4a6b7dce2f9">constrained_cg</a> (const TMatrix &amp;A, const CMatrix &amp;C, VectorX &amp;x, const VectorB &amp;b, const VectorF &amp;f, <a class="el" href="classEigen_1_1IterationController.html">IterationController</a> &amp;iter)</td></tr>
<tr class="separator:ga1c2f99746877fd46158af4a6b7dce2f9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a851df31ae9133639a8eb3f6a8484bbf7"><td class="memTemplParams" colspan="2">template&lt;typename MatrixType , typename Rhs , typename Dest , typename Preconditioner &gt; </td></tr>
<tr class="memitem:a851df31ae9133639a8eb3f6a8484bbf7"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceEigen_1_1internal.html#a851df31ae9133639a8eb3f6a8484bbf7">gmres</a> (const MatrixType &amp;mat, const Rhs &amp;rhs, Dest &amp;x, const Preconditioner &amp;precond, Index &amp;iters, const Index &amp;restart, typename Dest::RealScalar &amp;tol_error)</td></tr>
<tr class="separator:a851df31ae9133639a8eb3f6a8484bbf7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae7d0962a143c96343984440db683905a"><td class="memTemplParams" colspan="2">template&lt;typename MatA , typename MatU , typename MatV &gt; </td></tr>
<tr class="memitem:ae7d0962a143c96343984440db683905a"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceEigen_1_1internal.html#ae7d0962a143c96343984440db683905a">matrix_exp_pade13</a> (const MatA &amp;A, MatU &amp;U, MatV &amp;V)</td></tr>
<tr class="memdesc:ae7d0962a143c96343984440db683905a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the (13,13)-Pad&eacute; approximant to the exponential.  <a href="#ae7d0962a143c96343984440db683905a">More...</a><br /></td></tr>
<tr class="separator:ae7d0962a143c96343984440db683905a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7e6cf2e01b6fb376d33b9bb8183e5777"><td class="memTemplParams" colspan="2">template&lt;typename MatA , typename MatU , typename MatV &gt; </td></tr>
<tr class="memitem:a7e6cf2e01b6fb376d33b9bb8183e5777"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceEigen_1_1internal.html#a7e6cf2e01b6fb376d33b9bb8183e5777">matrix_exp_pade3</a> (const MatA &amp;A, MatU &amp;U, MatV &amp;V)</td></tr>
<tr class="memdesc:a7e6cf2e01b6fb376d33b9bb8183e5777"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the (3,3)-Pad&eacute; approximant to the exponential.  <a href="#a7e6cf2e01b6fb376d33b9bb8183e5777">More...</a><br /></td></tr>
<tr class="separator:a7e6cf2e01b6fb376d33b9bb8183e5777"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af4992d182490219270a24aaa8285e63a"><td class="memTemplParams" colspan="2">template&lt;typename MatA , typename MatU , typename MatV &gt; </td></tr>
<tr class="memitem:af4992d182490219270a24aaa8285e63a"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceEigen_1_1internal.html#af4992d182490219270a24aaa8285e63a">matrix_exp_pade5</a> (const MatA &amp;A, MatU &amp;U, MatV &amp;V)</td></tr>
<tr class="memdesc:af4992d182490219270a24aaa8285e63a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the (5,5)-Pad&eacute; approximant to the exponential.  <a href="#af4992d182490219270a24aaa8285e63a">More...</a><br /></td></tr>
<tr class="separator:af4992d182490219270a24aaa8285e63a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1abecb439e6cb1b5188828cdb7e0ab60"><td class="memTemplParams" colspan="2">template&lt;typename MatA , typename MatU , typename MatV &gt; </td></tr>
<tr class="memitem:a1abecb439e6cb1b5188828cdb7e0ab60"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceEigen_1_1internal.html#a1abecb439e6cb1b5188828cdb7e0ab60">matrix_exp_pade7</a> (const MatA &amp;A, MatU &amp;U, MatV &amp;V)</td></tr>
<tr class="memdesc:a1abecb439e6cb1b5188828cdb7e0ab60"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the (7,7)-Pad&eacute; approximant to the exponential.  <a href="#a1abecb439e6cb1b5188828cdb7e0ab60">More...</a><br /></td></tr>
<tr class="separator:a1abecb439e6cb1b5188828cdb7e0ab60"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a218447e97bf869bf354f92e020a7355a"><td class="memTemplParams" colspan="2">template&lt;typename MatA , typename MatU , typename MatV &gt; </td></tr>
<tr class="memitem:a218447e97bf869bf354f92e020a7355a"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceEigen_1_1internal.html#a218447e97bf869bf354f92e020a7355a">matrix_exp_pade9</a> (const MatA &amp;A, MatU &amp;U, MatV &amp;V)</td></tr>
<tr class="memdesc:a218447e97bf869bf354f92e020a7355a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the (9,9)-Pad&eacute; approximant to the exponential.  <a href="#a218447e97bf869bf354f92e020a7355a">More...</a><br /></td></tr>
<tr class="separator:a218447e97bf869bf354f92e020a7355a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8ff76c47bde59d8af688e5925bed8f17"><td class="memTemplParams" colspan="2">template&lt;typename MatrixType , typename VectorType &gt; </td></tr>
<tr class="memitem:a8ff76c47bde59d8af688e5925bed8f17"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceEigen_1_1internal.html#a8ff76c47bde59d8af688e5925bed8f17">matrix_function_compute_above_diagonal</a> (const MatrixType &amp;T, const VectorType &amp;blockStart, const VectorType &amp;clusterSize, MatrixType &amp;fT)</td></tr>
<tr class="memdesc:a8ff76c47bde59d8af688e5925bed8f17"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute part of matrix function above block diagonal.  <a href="#a8ff76c47bde59d8af688e5925bed8f17">More...</a><br /></td></tr>
<tr class="separator:a8ff76c47bde59d8af688e5925bed8f17"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a53e617df189868a791e44d2c4e94403f"><td class="memTemplParams" colspan="2">template&lt;typename MatrixType , typename AtomicType , typename VectorType &gt; </td></tr>
<tr class="memitem:a53e617df189868a791e44d2c4e94403f"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceEigen_1_1internal.html#a53e617df189868a791e44d2c4e94403f">matrix_function_compute_block_atomic</a> (const MatrixType &amp;T, AtomicType &amp;atomic, const VectorType &amp;blockStart, const VectorType &amp;clusterSize, MatrixType &amp;fT)</td></tr>
<tr class="memdesc:a53e617df189868a791e44d2c4e94403f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute block diagonal part of matrix function.  <a href="#a53e617df189868a791e44d2c4e94403f">More...</a><br /></td></tr>
<tr class="separator:a53e617df189868a791e44d2c4e94403f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2144f635d30028a25e7eb3510c315ad3"><td class="memTemplParams" colspan="2"><a id="a2144f635d30028a25e7eb3510c315ad3"></a>
template&lt;typename VectorType &gt; </td></tr>
<tr class="memitem:a2144f635d30028a25e7eb3510c315ad3"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceEigen_1_1internal.html#a2144f635d30028a25e7eb3510c315ad3">matrix_function_compute_block_start</a> (const VectorType &amp;clusterSize, VectorType &amp;blockStart)</td></tr>
<tr class="memdesc:a2144f635d30028a25e7eb3510c315ad3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute start of each block using clusterSize. <br /></td></tr>
<tr class="separator:a2144f635d30028a25e7eb3510c315ad3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1073ba7ac499827baa04c814e4251326"><td class="memTemplParams" colspan="2"><a id="a1073ba7ac499827baa04c814e4251326"></a>
template&lt;typename ListOfClusters , typename Index &gt; </td></tr>
<tr class="memitem:a1073ba7ac499827baa04c814e4251326"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceEigen_1_1internal.html#a1073ba7ac499827baa04c814e4251326">matrix_function_compute_cluster_size</a> (const ListOfClusters &amp;clusters, Matrix&lt; Index, Dynamic, 1 &gt; &amp;clusterSize)</td></tr>
<tr class="memdesc:a1073ba7ac499827baa04c814e4251326"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute size of each cluster given a partitioning. <br /></td></tr>
<tr class="separator:a1073ba7ac499827baa04c814e4251326"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ade67364a006320cd7103f0f3366def09"><td class="memTemplParams" colspan="2"><a id="ade67364a006320cd7103f0f3366def09"></a>
template&lt;typename EivalsType , typename ListOfClusters , typename VectorType &gt; </td></tr>
<tr class="memitem:ade67364a006320cd7103f0f3366def09"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceEigen_1_1internal.html#ade67364a006320cd7103f0f3366def09">matrix_function_compute_map</a> (const EivalsType &amp;eivals, const ListOfClusters &amp;clusters, VectorType &amp;eivalToCluster)</td></tr>
<tr class="memdesc:ade67364a006320cd7103f0f3366def09"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute mapping of eigenvalue indices to cluster indices. <br /></td></tr>
<tr class="separator:ade67364a006320cd7103f0f3366def09"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0434fe5b0ec47e69b8e351ef9e131bcd"><td class="memTemplParams" colspan="2"><a id="a0434fe5b0ec47e69b8e351ef9e131bcd"></a>
template&lt;typename DynVectorType , typename VectorType &gt; </td></tr>
<tr class="memitem:a0434fe5b0ec47e69b8e351ef9e131bcd"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceEigen_1_1internal.html#a0434fe5b0ec47e69b8e351ef9e131bcd">matrix_function_compute_permutation</a> (const DynVectorType &amp;blockStart, const DynVectorType &amp;eivalToCluster, VectorType &amp;permutation)</td></tr>
<tr class="memdesc:a0434fe5b0ec47e69b8e351ef9e131bcd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute permutation which groups ei'vals in same cluster together. <br /></td></tr>
<tr class="separator:a0434fe5b0ec47e69b8e351ef9e131bcd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af9cdbae9f4f166fae876c54b97c0f2bb"><td class="memTemplParams" colspan="2">template&lt;typename Index , typename ListOfClusters &gt; </td></tr>
<tr class="memitem:af9cdbae9f4f166fae876c54b97c0f2bb"><td class="memTemplItemLeft" align="right" valign="top">ListOfClusters::iterator&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceEigen_1_1internal.html#af9cdbae9f4f166fae876c54b97c0f2bb">matrix_function_find_cluster</a> (Index key, ListOfClusters &amp;clusters)</td></tr>
<tr class="memdesc:af9cdbae9f4f166fae876c54b97c0f2bb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find cluster in <code>clusters</code> containing some value.  <a href="#af9cdbae9f4f166fae876c54b97c0f2bb">More...</a><br /></td></tr>
<tr class="separator:af9cdbae9f4f166fae876c54b97c0f2bb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9291a6ab4fe0ad1346049a8f2feddeaa"><td class="memTemplParams" colspan="2">template&lt;typename EivalsType , typename Cluster &gt; </td></tr>
<tr class="memitem:a9291a6ab4fe0ad1346049a8f2feddeaa"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceEigen_1_1internal.html#a9291a6ab4fe0ad1346049a8f2feddeaa">matrix_function_partition_eigenvalues</a> (const EivalsType &amp;eivals, std::list&lt; Cluster &gt; &amp;clusters)</td></tr>
<tr class="memdesc:a9291a6ab4fe0ad1346049a8f2feddeaa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Partition eigenvalues in clusters of ei'vals close to each other.  <a href="#a9291a6ab4fe0ad1346049a8f2feddeaa">More...</a><br /></td></tr>
<tr class="separator:a9291a6ab4fe0ad1346049a8f2feddeaa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a59cacdc2f9b480da246258bc9399aa2c"><td class="memTemplParams" colspan="2"><a id="a59cacdc2f9b480da246258bc9399aa2c"></a>
template&lt;typename VectorType , typename MatrixType &gt; </td></tr>
<tr class="memitem:a59cacdc2f9b480da246258bc9399aa2c"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceEigen_1_1internal.html#a59cacdc2f9b480da246258bc9399aa2c">matrix_function_permute_schur</a> (VectorType &amp;permutation, MatrixType &amp;U, MatrixType &amp;T)</td></tr>
<tr class="memdesc:a59cacdc2f9b480da246258bc9399aa2c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Permute Schur decomposition in U and T according to permutation. <br /></td></tr>
<tr class="separator:a59cacdc2f9b480da246258bc9399aa2c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9f7e5b9803071057e7ed4e887da4a1bb"><td class="memTemplParams" colspan="2">template&lt;typename MatrixType &gt; </td></tr>
<tr class="memitem:a9f7e5b9803071057e7ed4e887da4a1bb"><td class="memTemplItemLeft" align="right" valign="top">MatrixType&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceEigen_1_1internal.html#a9f7e5b9803071057e7ed4e887da4a1bb">matrix_function_solve_triangular_sylvester</a> (const MatrixType &amp;A, const MatrixType &amp;B, const MatrixType &amp;C)</td></tr>
<tr class="memdesc:a9f7e5b9803071057e7ed4e887da4a1bb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Solve a triangular Sylvester equation AX + XB = C.  <a href="#a9f7e5b9803071057e7ed4e887da4a1bb">More...</a><br /></td></tr>
<tr class="separator:a9f7e5b9803071057e7ed4e887da4a1bb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1cb8d312c017f94570a52317fd1ece5f"><td class="memTemplParams" colspan="2"><a id="a1cb8d312c017f94570a52317fd1ece5f"></a>
template&lt;typename MatrixType &gt; </td></tr>
<tr class="memitem:a1cb8d312c017f94570a52317fd1ece5f"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceEigen_1_1internal.html#a1cb8d312c017f94570a52317fd1ece5f">matrix_log_compute_2x2</a> (const MatrixType &amp;A, MatrixType &amp;result)</td></tr>
<tr class="memdesc:a1cb8d312c017f94570a52317fd1ece5f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute logarithm of 2x2 triangular matrix. <br /></td></tr>
<tr class="separator:a1cb8d312c017f94570a52317fd1ece5f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac2de7acbbff34ec236ee5e9fdb2eee38"><td class="memTemplParams" colspan="2">template&lt;typename MatrixType &gt; </td></tr>
<tr class="memitem:ac2de7acbbff34ec236ee5e9fdb2eee38"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceEigen_1_1internal.html#ac2de7acbbff34ec236ee5e9fdb2eee38">matrix_log_compute_big</a> (const MatrixType &amp;A, MatrixType &amp;result)</td></tr>
<tr class="memdesc:ac2de7acbbff34ec236ee5e9fdb2eee38"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute logarithm of triangular matrices with size &gt; 2.  <a href="#ac2de7acbbff34ec236ee5e9fdb2eee38">More...</a><br /></td></tr>
<tr class="separator:ac2de7acbbff34ec236ee5e9fdb2eee38"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga58a0ccf0e71d88beeb5dcf72ed0bdd5f"><td class="memTemplParams" colspan="2">template&lt;typename CMatrix , typename CINVMatrix &gt; </td></tr>
<tr class="memitem:ga58a0ccf0e71d88beeb5dcf72ed0bdd5f"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__IterativeSolvers__Module.html#ga58a0ccf0e71d88beeb5dcf72ed0bdd5f">pseudo_inverse</a> (const CMatrix &amp;C, CINVMatrix &amp;CINV)</td></tr>
<tr class="separator:ga58a0ccf0e71d88beeb5dcf72ed0bdd5f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afe2a11c61eff70f7f68681a557fa21e7"><td class="memTemplParams" colspan="2">template&lt;typename VectorType , typename IndexType &gt; </td></tr>
<tr class="memitem:afe2a11c61eff70f7f68681a557fa21e7"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceEigen_1_1internal.html#afe2a11c61eff70f7f68681a557fa21e7">sortWithPermutation</a> (VectorType &amp;vec, IndexType &amp;perm, typename IndexType::Scalar &amp;ncut)</td></tr>
<tr class="memdesc:afe2a11c61eff70f7f68681a557fa21e7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes a permutation vector to have a sorted sequence.  <a href="#afe2a11c61eff70f7f68681a557fa21e7">More...</a><br /></td></tr>
<tr class="separator:afe2a11c61eff70f7f68681a557fa21e7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9727c15ffb97a40df226fce93e2628b3"><td class="memTemplParams" colspan="2"><a id="a9727c15ffb97a40df226fce93e2628b3"></a>
template&lt;typename Scalar &gt; </td></tr>
<tr class="memitem:a9727c15ffb97a40df226fce93e2628b3"><td class="memTemplItemLeft" align="right" valign="top">Scalar&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceEigen_1_1internal.html#a9727c15ffb97a40df226fce93e2628b3">stem_function_cos</a> (Scalar x, int n)</td></tr>
<tr class="memdesc:a9727c15ffb97a40df226fce93e2628b3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Cosine (and its derivatives). <br /></td></tr>
<tr class="separator:a9727c15ffb97a40df226fce93e2628b3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aab7949e5c95ec574eff5c4229da36846"><td class="memTemplParams" colspan="2"><a id="aab7949e5c95ec574eff5c4229da36846"></a>
template&lt;typename Scalar &gt; </td></tr>
<tr class="memitem:aab7949e5c95ec574eff5c4229da36846"><td class="memTemplItemLeft" align="right" valign="top">Scalar&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceEigen_1_1internal.html#aab7949e5c95ec574eff5c4229da36846">stem_function_cosh</a> (Scalar x, int n)</td></tr>
<tr class="memdesc:aab7949e5c95ec574eff5c4229da36846"><td class="mdescLeft">&#160;</td><td class="mdescRight">Hyperbolic cosine (and its derivatives). <br /></td></tr>
<tr class="separator:aab7949e5c95ec574eff5c4229da36846"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0e7bafccf7fa66d965ab6c59444a39c3"><td class="memTemplParams" colspan="2"><a id="a0e7bafccf7fa66d965ab6c59444a39c3"></a>
template&lt;typename Scalar &gt; </td></tr>
<tr class="memitem:a0e7bafccf7fa66d965ab6c59444a39c3"><td class="memTemplItemLeft" align="right" valign="top">Scalar&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceEigen_1_1internal.html#a0e7bafccf7fa66d965ab6c59444a39c3">stem_function_exp</a> (Scalar x, int)</td></tr>
<tr class="memdesc:a0e7bafccf7fa66d965ab6c59444a39c3"><td class="mdescLeft">&#160;</td><td class="mdescRight">The exponential function (and its derivatives). <br /></td></tr>
<tr class="separator:a0e7bafccf7fa66d965ab6c59444a39c3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a297dc38f5c9b80e2a1da7dcf2a453c90"><td class="memTemplParams" colspan="2"><a id="a297dc38f5c9b80e2a1da7dcf2a453c90"></a>
template&lt;typename Scalar &gt; </td></tr>
<tr class="memitem:a297dc38f5c9b80e2a1da7dcf2a453c90"><td class="memTemplItemLeft" align="right" valign="top">Scalar&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceEigen_1_1internal.html#a297dc38f5c9b80e2a1da7dcf2a453c90">stem_function_sin</a> (Scalar x, int n)</td></tr>
<tr class="memdesc:a297dc38f5c9b80e2a1da7dcf2a453c90"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sine (and its derivatives). <br /></td></tr>
<tr class="separator:a297dc38f5c9b80e2a1da7dcf2a453c90"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab2855d150c9eebb8ed6cb63a292dda0d"><td class="memTemplParams" colspan="2"><a id="ab2855d150c9eebb8ed6cb63a292dda0d"></a>
template&lt;typename Scalar &gt; </td></tr>
<tr class="memitem:ab2855d150c9eebb8ed6cb63a292dda0d"><td class="memTemplItemLeft" align="right" valign="top">Scalar&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceEigen_1_1internal.html#ab2855d150c9eebb8ed6cb63a292dda0d">stem_function_sinh</a> (Scalar x, int n)</td></tr>
<tr class="memdesc:ab2855d150c9eebb8ed6cb63a292dda0d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Hyperbolic sine (and its derivatives). <br /></td></tr>
<tr class="separator:ab2855d150c9eebb8ed6cb63a292dda0d"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>template &lt;class&gt; class MakePointer_ is added to convert the host pointer to the device pointer. It is added due to the fact that for our device compiler T* is not allowed. If we wanted to use the same Evaluator functions we have to convert that type to our pointer T. This is done through our MakePointer_ class. By default the Type in the MakePointer_&lt;T&gt; is T* . Therefore, by adding the default value, we managed to convert the type and it does not break any existing code as its default value is T*. </p>
</div><h2 class="groupheader">Function Documentation</h2>
<a id="a851df31ae9133639a8eb3f6a8484bbf7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a851df31ae9133639a8eb3f6a8484bbf7">&#9670;&nbsp;</a></span>gmres()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MatrixType , typename Rhs , typename Dest , typename Preconditioner &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool Eigen::internal::gmres </td>
          <td>(</td>
          <td class="paramtype">const MatrixType &amp;&#160;</td>
          <td class="paramname"><em>mat</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Rhs &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Dest &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Preconditioner &amp;&#160;</td>
          <td class="paramname"><em>precond</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Index &amp;&#160;</td>
          <td class="paramname"><em>iters</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Index &amp;&#160;</td>
          <td class="paramname"><em>restart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename Dest::RealScalar &amp;&#160;</td>
          <td class="paramname"><em>tol_error</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Generalized Minimal Residual Algorithm based on the Arnoldi algorithm implemented with Householder reflections.</p>
<p>Parameters: </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mat</td><td>matrix of linear system of equations </td></tr>
    <tr><td class="paramname">Rhs</td><td>right hand side vector of linear system of equations </td></tr>
    <tr><td class="paramname">x</td><td>on input: initial guess, on output: solution </td></tr>
    <tr><td class="paramname">precond</td><td>preconditioner used </td></tr>
    <tr><td class="paramname">iters</td><td>on input: maximum number of iterations to perform on output: number of iterations performed </td></tr>
    <tr><td class="paramname">restart</td><td>number of iterations for a restart </td></tr>
    <tr><td class="paramname">tol_error</td><td>on input: relative residual tolerance on output: residuum achieved</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd>IterativeMethods::bicgstab()</dd></dl>
<p>For references, please see:</p>
<p>Saad, Y. and Schultz, M. H. <a class="el" href="classEigen_1_1GMRES.html" title="A GMRES solver for sparse square problems. ">GMRES</a>: A Generalized Minimal Residual Algorithm for Solving Nonsymmetric Linear Systems. SIAM J.Sci.Stat.Comp. 7, 1986, pp. 856 - 869.</p>
<p>Saad, Y. Iterative Methods for Sparse Linear Systems. Society for Industrial and Applied Mathematics, Philadelphia, 2003.</p>
<p>Walker, H. F. Implementations of the <a class="el" href="classEigen_1_1GMRES.html" title="A GMRES solver for sparse square problems. ">GMRES</a> method. Comput.Phys.Comm. 53, 1989, pp. 311 - 320.</p>
<p>Walker, H. F. Implementation of the <a class="el" href="classEigen_1_1GMRES.html" title="A GMRES solver for sparse square problems. ">GMRES</a> Method using Householder Transformations. SIAM J.Sci.Stat.Comp. 9, 1988, pp. 152 - 163. </p>

</div>
</div>
<a id="ae7d0962a143c96343984440db683905a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae7d0962a143c96343984440db683905a">&#9670;&nbsp;</a></span>matrix_exp_pade13()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MatA , typename MatU , typename MatV &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void Eigen::internal::matrix_exp_pade13 </td>
          <td>(</td>
          <td class="paramtype">const MatA &amp;&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">MatU &amp;&#160;</td>
          <td class="paramname"><em>U</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">MatV &amp;&#160;</td>
          <td class="paramname"><em>V</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute the (13,13)-Pad&eacute; approximant to the exponential. </p>
<p>After exit, <img class="formulaInl" alt="$ (V+U)(V-U)^{-1} $" src="form_70.png"/> is the Pad&eacute; approximant of <img class="formulaInl" alt="$ \exp(A) $" src="form_71.png"/> around <img class="formulaInl" alt="$ A = 0 $" src="form_72.png"/>. </p>

</div>
</div>
<a id="a7e6cf2e01b6fb376d33b9bb8183e5777"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7e6cf2e01b6fb376d33b9bb8183e5777">&#9670;&nbsp;</a></span>matrix_exp_pade3()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MatA , typename MatU , typename MatV &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void Eigen::internal::matrix_exp_pade3 </td>
          <td>(</td>
          <td class="paramtype">const MatA &amp;&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">MatU &amp;&#160;</td>
          <td class="paramname"><em>U</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">MatV &amp;&#160;</td>
          <td class="paramname"><em>V</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute the (3,3)-Pad&eacute; approximant to the exponential. </p>
<p>After exit, <img class="formulaInl" alt="$ (V+U)(V-U)^{-1} $" src="form_70.png"/> is the Pad&eacute; approximant of <img class="formulaInl" alt="$ \exp(A) $" src="form_71.png"/> around <img class="formulaInl" alt="$ A = 0 $" src="form_72.png"/>. </p>

</div>
</div>
<a id="af4992d182490219270a24aaa8285e63a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af4992d182490219270a24aaa8285e63a">&#9670;&nbsp;</a></span>matrix_exp_pade5()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MatA , typename MatU , typename MatV &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void Eigen::internal::matrix_exp_pade5 </td>
          <td>(</td>
          <td class="paramtype">const MatA &amp;&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">MatU &amp;&#160;</td>
          <td class="paramname"><em>U</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">MatV &amp;&#160;</td>
          <td class="paramname"><em>V</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute the (5,5)-Pad&eacute; approximant to the exponential. </p>
<p>After exit, <img class="formulaInl" alt="$ (V+U)(V-U)^{-1} $" src="form_70.png"/> is the Pad&eacute; approximant of <img class="formulaInl" alt="$ \exp(A) $" src="form_71.png"/> around <img class="formulaInl" alt="$ A = 0 $" src="form_72.png"/>. </p>

</div>
</div>
<a id="a1abecb439e6cb1b5188828cdb7e0ab60"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1abecb439e6cb1b5188828cdb7e0ab60">&#9670;&nbsp;</a></span>matrix_exp_pade7()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MatA , typename MatU , typename MatV &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void Eigen::internal::matrix_exp_pade7 </td>
          <td>(</td>
          <td class="paramtype">const MatA &amp;&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">MatU &amp;&#160;</td>
          <td class="paramname"><em>U</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">MatV &amp;&#160;</td>
          <td class="paramname"><em>V</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute the (7,7)-Pad&eacute; approximant to the exponential. </p>
<p>After exit, <img class="formulaInl" alt="$ (V+U)(V-U)^{-1} $" src="form_70.png"/> is the Pad&eacute; approximant of <img class="formulaInl" alt="$ \exp(A) $" src="form_71.png"/> around <img class="formulaInl" alt="$ A = 0 $" src="form_72.png"/>. </p>

</div>
</div>
<a id="a218447e97bf869bf354f92e020a7355a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a218447e97bf869bf354f92e020a7355a">&#9670;&nbsp;</a></span>matrix_exp_pade9()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MatA , typename MatU , typename MatV &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void Eigen::internal::matrix_exp_pade9 </td>
          <td>(</td>
          <td class="paramtype">const MatA &amp;&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">MatU &amp;&#160;</td>
          <td class="paramname"><em>U</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">MatV &amp;&#160;</td>
          <td class="paramname"><em>V</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute the (9,9)-Pad&eacute; approximant to the exponential. </p>
<p>After exit, <img class="formulaInl" alt="$ (V+U)(V-U)^{-1} $" src="form_70.png"/> is the Pad&eacute; approximant of <img class="formulaInl" alt="$ \exp(A) $" src="form_71.png"/> around <img class="formulaInl" alt="$ A = 0 $" src="form_72.png"/>. </p>

</div>
</div>
<a id="a8ff76c47bde59d8af688e5925bed8f17"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8ff76c47bde59d8af688e5925bed8f17">&#9670;&nbsp;</a></span>matrix_function_compute_above_diagonal()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MatrixType , typename VectorType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void Eigen::internal::matrix_function_compute_above_diagonal </td>
          <td>(</td>
          <td class="paramtype">const MatrixType &amp;&#160;</td>
          <td class="paramname"><em>T</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const VectorType &amp;&#160;</td>
          <td class="paramname"><em>blockStart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const VectorType &amp;&#160;</td>
          <td class="paramname"><em>clusterSize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">MatrixType &amp;&#160;</td>
          <td class="paramname"><em>fT</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute part of matrix function above block diagonal. </p>
<p>This routine completes the computation of <code>fT</code>, denoting a matrix function applied to the triangular matrix <code>T</code>. It assumes that the block diagonal part of <code>fT</code> has already been computed. The part below the diagonal is zero, because <code>T</code> is upper triangular. </p>

</div>
</div>
<a id="a53e617df189868a791e44d2c4e94403f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a53e617df189868a791e44d2c4e94403f">&#9670;&nbsp;</a></span>matrix_function_compute_block_atomic()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MatrixType , typename AtomicType , typename VectorType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void Eigen::internal::matrix_function_compute_block_atomic </td>
          <td>(</td>
          <td class="paramtype">const MatrixType &amp;&#160;</td>
          <td class="paramname"><em>T</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">AtomicType &amp;&#160;</td>
          <td class="paramname"><em>atomic</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const VectorType &amp;&#160;</td>
          <td class="paramname"><em>blockStart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const VectorType &amp;&#160;</td>
          <td class="paramname"><em>clusterSize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">MatrixType &amp;&#160;</td>
          <td class="paramname"><em>fT</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute block diagonal part of matrix function. </p>
<p>This routine computes the matrix function applied to the block diagonal part of <code>T</code> (which should be upper triangular), with the blocking given by <code>blockStart</code> and <code>clusterSize</code>. The matrix function of each diagonal block is computed by <code>atomic</code>. The off-diagonal parts of <code>fT</code> are set to zero. </p>

</div>
</div>
<a id="af9cdbae9f4f166fae876c54b97c0f2bb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af9cdbae9f4f166fae876c54b97c0f2bb">&#9670;&nbsp;</a></span>matrix_function_find_cluster()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Index , typename ListOfClusters &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">ListOfClusters::iterator Eigen::internal::matrix_function_find_cluster </td>
          <td>(</td>
          <td class="paramtype">Index&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ListOfClusters &amp;&#160;</td>
          <td class="paramname"><em>clusters</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Find cluster in <code>clusters</code> containing some value. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">key</td><td>Value to find </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Iterator to cluster containing <code>key</code>, or <code>clusters.end()</code> if no cluster in <code>m_clusters</code> contains <code>key</code>. </dd></dl>

</div>
</div>
<a id="a9291a6ab4fe0ad1346049a8f2feddeaa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9291a6ab4fe0ad1346049a8f2feddeaa">&#9670;&nbsp;</a></span>matrix_function_partition_eigenvalues()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename EivalsType , typename Cluster &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void Eigen::internal::matrix_function_partition_eigenvalues </td>
          <td>(</td>
          <td class="paramtype">const EivalsType &amp;&#160;</td>
          <td class="paramname"><em>eivals</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::list&lt; Cluster &gt; &amp;&#160;</td>
          <td class="paramname"><em>clusters</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Partition eigenvalues in clusters of ei'vals close to each other. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">eivals</td><td>Eigenvalues </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">clusters</td><td>Resulting partition of eigenvalues</td></tr>
  </table>
  </dd>
</dl>
<p>The partition satisfies the following two properties: </p><h1>Any eigenvalue in a certain cluster is at most matrix_function_separation() away from another eigenvalue</h1>
<p>in the same cluster. </p><h1>The distance between two eigenvalues in different clusters is more than matrix_function_separation().</h1>
<p>The implementation follows Algorithm 4.1 in the paper of Davies and Higham. </p>

</div>
</div>
<a id="a9f7e5b9803071057e7ed4e887da4a1bb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9f7e5b9803071057e7ed4e887da4a1bb">&#9670;&nbsp;</a></span>matrix_function_solve_triangular_sylvester()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MatrixType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">MatrixType Eigen::internal::matrix_function_solve_triangular_sylvester </td>
          <td>(</td>
          <td class="paramtype">const MatrixType &amp;&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const MatrixType &amp;&#160;</td>
          <td class="paramname"><em>B</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const MatrixType &amp;&#160;</td>
          <td class="paramname"><em>C</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Solve a triangular Sylvester equation AX + XB = C. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">A</td><td>the matrix A; should be square and upper triangular </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">B</td><td>the matrix B; should be square and upper triangular </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">C</td><td>the matrix C; should have correct size.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the solution X.</dd></dl>
<p>If A is m-by-m and B is n-by-n, then both C and X are m-by-n. The (i,j)-th component of the Sylvester equation is </p><p class="formulaDsp">
<img class="formulaDsp" alt="\[ \sum_{k=i}^m A_{ik} X_{kj} + \sum_{k=1}^j X_{ik} B_{kj} = C_{ij}. \]" src="form_77.png"/>
</p>
<p> This can be re-arranged to yield: </p><p class="formulaDsp">
<img class="formulaDsp" alt="\[ X_{ij} = \frac{1}{A_{ii} + B_{jj}} \Bigl( C_{ij} - \sum_{k=i+1}^m A_{ik} X_{kj} - \sum_{k=1}^{j-1} X_{ik} B_{kj} \Bigr). \]" src="form_78.png"/>
</p>
<p> It is assumed that A and B are such that the numerator is never zero (otherwise the Sylvester equation does not have a unique solution). In that case, these equations can be evaluated in the order <img class="formulaInl" alt="$ i=m,\ldots,1 $" src="form_79.png"/> and <img class="formulaInl" alt="$ j=1,\ldots,n $" src="form_80.png"/>. </p>

</div>
</div>
<a id="ac2de7acbbff34ec236ee5e9fdb2eee38"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac2de7acbbff34ec236ee5e9fdb2eee38">&#9670;&nbsp;</a></span>matrix_log_compute_big()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MatrixType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void Eigen::internal::matrix_log_compute_big </td>
          <td>(</td>
          <td class="paramtype">const MatrixType &amp;&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">MatrixType &amp;&#160;</td>
          <td class="paramname"><em>result</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute logarithm of triangular matrices with size &gt; 2. </p>
<p>This uses a inverse scale-and-square algorithm. </p>

</div>
</div>
<a id="afe2a11c61eff70f7f68681a557fa21e7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afe2a11c61eff70f7f68681a557fa21e7">&#9670;&nbsp;</a></span>sortWithPermutation()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename VectorType , typename IndexType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void Eigen::internal::sortWithPermutation </td>
          <td>(</td>
          <td class="paramtype">VectorType &amp;&#160;</td>
          <td class="paramname"><em>vec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">IndexType &amp;&#160;</td>
          <td class="paramname"><em>perm</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename IndexType::Scalar &amp;&#160;</td>
          <td class="paramname"><em>ncut</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes a permutation vector to have a sorted sequence. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vec</td><td>The vector to reorder. </td></tr>
    <tr><td class="paramname">perm</td><td>gives the sorted sequence on output. Must be initialized with 0..n-1 </td></tr>
    <tr><td class="paramname">ncut</td><td>Put the ncut smallest elements at the end of the vector WARNING This is an expensive sort, so should be used only for small size vectors TODO Use modified QuickSplit or std::nth_element to get the smallest values </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="namespaceEigen.html">Eigen</a></li><li class="navelem"><a class="el" href="namespaceEigen_1_1internal.html">internal</a></li>
    <li class="footer">Generated on Mon Feb 26 2018 06:38:53 for Eigen-unsupported by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.13 </li>
  </ul>
</div>
<!-- Piwik -->
<script type="text/javascript">
var pkBaseURL = (("https:" == document.location.protocol) ? "https://stats.sylphide-consulting.com/piwik/" : "http://stats.sylphide-consulting.com/piwik/");
document.write(unescape("%3Cscript src='" + pkBaseURL + "piwik.js' type='text/javascript'%3E%3C/script%3E"));
</script><script type="text/javascript">
try {
var piwikTracker = Piwik.getTracker(pkBaseURL + "piwik.php", 20);
piwikTracker.trackPageView();
piwikTracker.enableLinkTracking();
} catch( err ) {}
</script><noscript><p><img src="http://stats.sylphide-consulting.com/piwik/piwik.php?idsite=20" style="border:0" alt="" /></p></noscript>
<!-- End Piwik Tracking Code -->
</body>
</html>
