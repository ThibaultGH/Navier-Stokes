<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<title>Eigen-unsupported: Eigen Namespace Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { init_search(); });
</script>
<link href="doxygen.css"   rel="stylesheet" type="text/css" />
<link href="eigendoxy.css" rel="stylesheet" type="text/css">
<!--  -->
<script type="text/javascript" src="eigen_navtree_hacks.js"></script>
<!-- <script type="text/javascript"> -->
<!-- </script> -->
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<!-- <a name="top"></a> -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="Eigen_Silly_Professor_64x64.png"/></td>
  <td style="padding-left: 0.5em;">
   <div id="projectname"><a href="http://eigen.tuxfamily.org">Eigen-unsupported</a>
   &#160;<span id="projectnumber">3.3.4</span>
   </div>
  </td>
   <td>        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
</td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('namespaceEigen.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#namespaces">Namespaces</a> &#124;
<a href="#nested-classes">Classes</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#enum-members">Enumerations</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">Eigen Namespace Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>Namespace containing all symbols from the Eigen library.  
<a href="#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="namespaces"></a>
Namespaces</h2></td></tr>
<tr class="memitem:namespaceEigen_1_1internal"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceEigen_1_1internal.html">internal</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEigen_1_1AlignedVector3.html">AlignedVector3</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A vectorization friendly 3D vector.  <a href="classEigen_1_1AlignedVector3.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEigen_1_1AutoDiffScalar.html">AutoDiffScalar</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A scalar type replacement with automatic differentation capability.  <a href="classEigen_1_1AutoDiffScalar.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEigen_1_1BlockSparseMatrix.html">BlockSparseMatrix</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A versatile sparse matrix representation where each element is a block.  <a href="classEigen_1_1BlockSparseMatrix.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEigen_1_1DGMRES.html">DGMRES</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A Restarted <a class="el" href="classEigen_1_1GMRES.html" title="A GMRES solver for sparse square problems. ">GMRES</a> with deflation. This class implements a modification of the <a class="el" href="classEigen_1_1GMRES.html" title="A GMRES solver for sparse square problems. ">GMRES</a> solver for sparse linear systems. The basis is built with modified Gram-Schmidt. At each restart, a few approximated eigenvectors corresponding to the smallest eigenvalues are used to build a preconditioner for the next cycle. This preconditioner for deflation can be combined with any other preconditioner, the IncompleteLUT for instance. The preconditioner is applied at right of the matrix and the combination is multiplicative.  <a href="classEigen_1_1DGMRES.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEigen_1_1DynamicSGroup.html">DynamicSGroup</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Dynamic symmetry group.  <a href="classEigen_1_1DynamicSGroup.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEigen_1_1DynamicSparseMatrix.html">DynamicSparseMatrix</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A sparse matrix class designed for matrix assembly purpose.  <a href="classEigen_1_1DynamicSparseMatrix.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEigen_1_1EulerAngles.html">EulerAngles</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Represents a rotation in a 3 dimensional space as three Euler angles.  <a href="classEigen_1_1EulerAngles.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEigen_1_1EulerSystem.html">EulerSystem</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Represents a fixed Euler rotation system.  <a href="classEigen_1_1EulerSystem.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEigen_1_1GMRES.html">GMRES</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A <a class="el" href="classEigen_1_1GMRES.html" title="A GMRES solver for sparse square problems. ">GMRES</a> solver for sparse square problems.  <a href="classEigen_1_1GMRES.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEigen_1_1HybridNonLinearSolver.html">HybridNonLinearSolver</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds a zero of a system of n nonlinear functions in n variables by a modification of the Powell hybrid method ("dogleg").  <a href="classEigen_1_1HybridNonLinearSolver.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEigen_1_1IterationController.html">IterationController</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Controls the iterations of the iterative solvers.  <a href="classEigen_1_1IterationController.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEigen_1_1IterScaling.html">IterScaling</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">iterative scaling algorithm to equilibrate rows and column norms in matrices  <a href="classEigen_1_1IterScaling.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEigen_1_1KdBVH.html">KdBVH</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A simple bounding volume hierarchy based on AlignedBox.  <a href="classEigen_1_1KdBVH.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEigen_1_1KroneckerProduct.html">KroneckerProduct</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Kronecker tensor product helper class for dense matrices.  <a href="classEigen_1_1KroneckerProduct.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEigen_1_1KroneckerProductBase.html">KroneckerProductBase</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The base class of dense and sparse Kronecker product.  <a href="classEigen_1_1KroneckerProductBase.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEigen_1_1KroneckerProductSparse.html">KroneckerProductSparse</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Kronecker tensor product helper class for sparse matrices.  <a href="classEigen_1_1KroneckerProductSparse.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEigen_1_1LevenbergMarquardt.html">LevenbergMarquardt</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs non linear optimization over a non-linear function, using a variant of the Levenberg Marquardt algorithm.  <a href="classEigen_1_1LevenbergMarquardt.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEigen_1_1MatrixComplexPowerReturnValue.html">MatrixComplexPowerReturnValue</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Proxy for the matrix power of some matrix (expression).  <a href="classEigen_1_1MatrixComplexPowerReturnValue.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structEigen_1_1MatrixExponentialReturnValue.html">MatrixExponentialReturnValue</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Proxy for the matrix exponential of some matrix (expression).  <a href="structEigen_1_1MatrixExponentialReturnValue.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEigen_1_1MatrixFunctionReturnValue.html">MatrixFunctionReturnValue</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Proxy for the matrix function of some matrix (expression).  <a href="classEigen_1_1MatrixFunctionReturnValue.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEigen_1_1MatrixLogarithmReturnValue.html">MatrixLogarithmReturnValue</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Proxy for the matrix logarithm of some matrix (expression).  <a href="classEigen_1_1MatrixLogarithmReturnValue.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEigen_1_1MatrixMarketIterator.html">MatrixMarketIterator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Iterator to browse matrices from a specified folder.  <a href="classEigen_1_1MatrixMarketIterator.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEigen_1_1MatrixPower.html">MatrixPower</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Class for computing matrix powers.  <a href="classEigen_1_1MatrixPower.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEigen_1_1MatrixPowerAtomic.html">MatrixPowerAtomic</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Class for computing matrix powers.  <a href="classEigen_1_1MatrixPowerAtomic.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEigen_1_1MatrixPowerParenthesesReturnValue.html">MatrixPowerParenthesesReturnValue</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Proxy for the matrix power of some matrix.  <a href="classEigen_1_1MatrixPowerParenthesesReturnValue.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEigen_1_1MatrixPowerReturnValue.html">MatrixPowerReturnValue</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Proxy for the matrix power of some matrix (expression).  <a href="classEigen_1_1MatrixPowerReturnValue.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEigen_1_1MatrixSquareRootReturnValue.html">MatrixSquareRootReturnValue</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Proxy for the matrix square root of some matrix (expression).  <a href="classEigen_1_1MatrixSquareRootReturnValue.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEigen_1_1MaxSizeVector.html">MaxSizeVector</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The <a class="el" href="classEigen_1_1MaxSizeVector.html" title="The MaxSizeVector class. ">MaxSizeVector</a> class.  <a href="classEigen_1_1MaxSizeVector.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEigen_1_1MINRES.html">MINRES</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A minimal residual solver for sparse symmetric problems.  <a href="classEigen_1_1MINRES.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEigen_1_1NumericalDiff.html">NumericalDiff</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEigen_1_1PolynomialSolver.html">PolynomialSolver</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A polynomial solver.  <a href="classEigen_1_1PolynomialSolver.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEigen_1_1PolynomialSolverBase.html">PolynomialSolverBase</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Defined to be inherited by polynomial solvers: it provides convenient methods such as.  <a href="classEigen_1_1PolynomialSolverBase.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEigen_1_1RandomSetter.html">RandomSetter</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The <a class="el" href="classEigen_1_1RandomSetter.html" title="The RandomSetter is a wrapper object allowing to set/update a sparse matrix with random access...">RandomSetter</a> is a wrapper object allowing to set/update a sparse matrix with random access.  <a href="classEigen_1_1RandomSetter.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEigen_1_1SGroup.html">SGroup</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Symmetry group, initialized from template arguments.  <a href="classEigen_1_1SGroup.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEigen_1_1SkylineInplaceLU.html">SkylineInplaceLU</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inplace LU decomposition of a skyline matrix and associated features.  <a href="classEigen_1_1SkylineInplaceLU.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEigen_1_1SkylineMatrix.html">SkylineMatrix</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The main skyline matrix class.  <a href="classEigen_1_1SkylineMatrix.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEigen_1_1SkylineMatrixBase.html">SkylineMatrixBase</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Base class of any skyline matrices or skyline expressions.  <a href="classEigen_1_1SkylineMatrixBase.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEigen_1_1SkylineStorage.html">SkylineStorage</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEigen_1_1Spline.html">Spline</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A class representing multi-dimensional spline curves.  <a href="classEigen_1_1Spline.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structEigen_1_1SplineFitting.html">SplineFitting</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classEigen_1_1Spline.html" title="A class representing multi-dimensional spline curves. ">Spline</a> fitting methods.  <a href="structEigen_1_1SplineFitting.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structEigen_1_1SplineTraits_3_01Spline_3_01__Scalar_00_01__Dim_00_01__Degree_01_4_00_01__DerivativeOrder_01_4.html">SplineTraits&lt; Spline&lt; _Scalar, _Dim, _Degree &gt;, _DerivativeOrder &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compile-time attributes of the <a class="el" href="classEigen_1_1Spline.html" title="A class representing multi-dimensional spline curves. ">Spline</a> class for fixed degree.  <a href="structEigen_1_1SplineTraits_3_01Spline_3_01__Scalar_00_01__Dim_00_01__Degree_01_4_00_01__DerivativeOrder_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structEigen_1_1SplineTraits_3_01Spline_3_01__Scalar_00_01__Dim_00_01__Degree_01_4_00_01Dynamic_01_4.html">SplineTraits&lt; Spline&lt; _Scalar, _Dim, _Degree &gt;, Dynamic &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compile-time attributes of the <a class="el" href="classEigen_1_1Spline.html" title="A class representing multi-dimensional spline curves. ">Spline</a> class for Dynamic degree.  <a href="structEigen_1_1SplineTraits_3_01Spline_3_01__Scalar_00_01__Dim_00_01__Degree_01_4_00_01Dynamic_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEigen_1_1StaticSGroup.html">StaticSGroup</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Static symmetry group.  <a href="classEigen_1_1StaticSGroup.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structEigen_1_1StdMapTraits.html">StdMapTraits</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEigen_1_1Tensor.html">Tensor</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The tensor class.  <a href="classEigen_1_1Tensor.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEigen_1_1TensorBase.html">TensorBase</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The tensor base class.  <a href="classEigen_1_1TensorBase.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEigen_1_1TensorConcatenationOp.html">TensorConcatenationOp</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classEigen_1_1Tensor.html" title="The tensor class. ">Tensor</a> concatenation class.  <a href="classEigen_1_1TensorConcatenationOp.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEigen_1_1TensorConversionOp.html">TensorConversionOp</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classEigen_1_1Tensor.html" title="The tensor class. ">Tensor</a> conversion class. This class makes it possible to vectorize type casting operations when the number of scalars per packet in the source and the destination type differ.  <a href="classEigen_1_1TensorConversionOp.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEigen_1_1TensorCustomBinaryOp.html">TensorCustomBinaryOp</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classEigen_1_1Tensor.html" title="The tensor class. ">Tensor</a> custom class.  <a href="classEigen_1_1TensorCustomBinaryOp.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEigen_1_1TensorCustomUnaryOp.html">TensorCustomUnaryOp</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classEigen_1_1Tensor.html" title="The tensor class. ">Tensor</a> custom class.  <a href="classEigen_1_1TensorCustomUnaryOp.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEigen_1_1TensorDevice.html">TensorDevice</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pseudo expression providing an operator = that will evaluate its argument on the specified computing 'device' (GPU, thread pool, ...)  <a href="classEigen_1_1TensorDevice.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structEigen_1_1TensorEvaluator.html">TensorEvaluator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A cost model used to limit the number of threads used for evaluating tensor expression.  <a href="structEigen_1_1TensorEvaluator.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEigen_1_1TensorFixedSize.html">TensorFixedSize</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The fixed sized version of the tensor class.  <a href="classEigen_1_1TensorFixedSize.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEigen_1_1TensorMap.html">TensorMap</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A tensor expression mapping an existing array of data.  <a href="classEigen_1_1TensorMap.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEigen_1_1TensorRef.html">TensorRef</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A reference to a tensor expression The expression will be evaluated lazily (as much as possible).  <a href="classEigen_1_1TensorRef.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:ga409ece4f53f28fca09e41a705651ce48"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="classEigen_1_1EulerAngles.html">EulerAngles</a>&lt; double, <a class="el" href="group__EulerAngles__Module.html#gaf31ed290215ceddba27c304bb8537ed1">EulerSystemXYX</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__EulerAngles__Module.html#ga409ece4f53f28fca09e41a705651ce48">EulerAnglesXYXd</a></td></tr>
<tr class="separator:ga409ece4f53f28fca09e41a705651ce48"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5a160649131f84254585880a440aa0d2"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="classEigen_1_1EulerAngles.html">EulerAngles</a>&lt; float, <a class="el" href="group__EulerAngles__Module.html#gaf31ed290215ceddba27c304bb8537ed1">EulerSystemXYX</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__EulerAngles__Module.html#ga5a160649131f84254585880a440aa0d2">EulerAnglesXYXf</a></td></tr>
<tr class="separator:ga5a160649131f84254585880a440aa0d2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga861bc3a579ec33581769d5266b6f6807"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="classEigen_1_1EulerAngles.html">EulerAngles</a>&lt; double, <a class="el" href="group__EulerAngles__Module.html#ga7c4d42543380af953bfc009fa012d8a6">EulerSystemXYZ</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__EulerAngles__Module.html#ga861bc3a579ec33581769d5266b6f6807">EulerAnglesXYZd</a></td></tr>
<tr class="separator:ga861bc3a579ec33581769d5266b6f6807"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga53fe408232ad7621d6a443d76f9ac93d"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="classEigen_1_1EulerAngles.html">EulerAngles</a>&lt; float, <a class="el" href="group__EulerAngles__Module.html#ga7c4d42543380af953bfc009fa012d8a6">EulerSystemXYZ</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__EulerAngles__Module.html#ga53fe408232ad7621d6a443d76f9ac93d">EulerAnglesXYZf</a></td></tr>
<tr class="separator:ga53fe408232ad7621d6a443d76f9ac93d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad106302a1f6e1fcea51830f2ff42e94a"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="classEigen_1_1EulerAngles.html">EulerAngles</a>&lt; double, <a class="el" href="group__EulerAngles__Module.html#ga0080bc8af60feb746663bd83e930b39e">EulerSystemXZX</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__EulerAngles__Module.html#gad106302a1f6e1fcea51830f2ff42e94a">EulerAnglesXZXd</a></td></tr>
<tr class="separator:gad106302a1f6e1fcea51830f2ff42e94a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4c6a4ad5a71566605a8794ff4c4fa5e0"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="classEigen_1_1EulerAngles.html">EulerAngles</a>&lt; float, <a class="el" href="group__EulerAngles__Module.html#ga0080bc8af60feb746663bd83e930b39e">EulerSystemXZX</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__EulerAngles__Module.html#ga4c6a4ad5a71566605a8794ff4c4fa5e0">EulerAnglesXZXf</a></td></tr>
<tr class="separator:ga4c6a4ad5a71566605a8794ff4c4fa5e0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9d8eba2490e596e5f733c6e99f580d5f"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="classEigen_1_1EulerAngles.html">EulerAngles</a>&lt; double, <a class="el" href="group__EulerAngles__Module.html#ga35f001d8aeef43d6a3d661c6e70dd762">EulerSystemXZY</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__EulerAngles__Module.html#ga9d8eba2490e596e5f733c6e99f580d5f">EulerAnglesXZYd</a></td></tr>
<tr class="separator:ga9d8eba2490e596e5f733c6e99f580d5f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae28ed3be70d16192d0933a5458802094"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="classEigen_1_1EulerAngles.html">EulerAngles</a>&lt; float, <a class="el" href="group__EulerAngles__Module.html#ga35f001d8aeef43d6a3d661c6e70dd762">EulerSystemXZY</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__EulerAngles__Module.html#gae28ed3be70d16192d0933a5458802094">EulerAnglesXZYf</a></td></tr>
<tr class="separator:gae28ed3be70d16192d0933a5458802094"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabafb17a58c430c0abc5bfa7d4925d10d"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="classEigen_1_1EulerAngles.html">EulerAngles</a>&lt; double, <a class="el" href="group__EulerAngles__Module.html#gabeaefca8d5f5f9ddeac746b3ba3945fa">EulerSystemYXY</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__EulerAngles__Module.html#gabafb17a58c430c0abc5bfa7d4925d10d">EulerAnglesYXYd</a></td></tr>
<tr class="separator:gabafb17a58c430c0abc5bfa7d4925d10d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga21b9f67580cd78643d3d08a44d8ef93c"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="classEigen_1_1EulerAngles.html">EulerAngles</a>&lt; float, <a class="el" href="group__EulerAngles__Module.html#gabeaefca8d5f5f9ddeac746b3ba3945fa">EulerSystemYXY</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__EulerAngles__Module.html#ga21b9f67580cd78643d3d08a44d8ef93c">EulerAnglesYXYf</a></td></tr>
<tr class="separator:ga21b9f67580cd78643d3d08a44d8ef93c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga001f9fbfc82948f04dff2790ba32dc8f"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="classEigen_1_1EulerAngles.html">EulerAngles</a>&lt; double, <a class="el" href="group__EulerAngles__Module.html#gac043703434ad0ccdb513953b1393df8f">EulerSystemYXZ</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__EulerAngles__Module.html#ga001f9fbfc82948f04dff2790ba32dc8f">EulerAnglesYXZd</a></td></tr>
<tr class="separator:ga001f9fbfc82948f04dff2790ba32dc8f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6843b6cd5803f635ee866ff61a5a06ed"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="classEigen_1_1EulerAngles.html">EulerAngles</a>&lt; float, <a class="el" href="group__EulerAngles__Module.html#gac043703434ad0ccdb513953b1393df8f">EulerSystemYXZ</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__EulerAngles__Module.html#ga6843b6cd5803f635ee866ff61a5a06ed">EulerAnglesYXZf</a></td></tr>
<tr class="separator:ga6843b6cd5803f635ee866ff61a5a06ed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga848046359634eda7cec3f57c0461460e"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="classEigen_1_1EulerAngles.html">EulerAngles</a>&lt; double, <a class="el" href="group__EulerAngles__Module.html#ga3a02c9a9ed8ae8286b003246064e7ddd">EulerSystemYZX</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__EulerAngles__Module.html#ga848046359634eda7cec3f57c0461460e">EulerAnglesYZXd</a></td></tr>
<tr class="separator:ga848046359634eda7cec3f57c0461460e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafbc20c24cc82d1450dfc1254276f4b7c"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="classEigen_1_1EulerAngles.html">EulerAngles</a>&lt; float, <a class="el" href="group__EulerAngles__Module.html#ga3a02c9a9ed8ae8286b003246064e7ddd">EulerSystemYZX</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__EulerAngles__Module.html#gafbc20c24cc82d1450dfc1254276f4b7c">EulerAnglesYZXf</a></td></tr>
<tr class="separator:gafbc20c24cc82d1450dfc1254276f4b7c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga48505785c62a6e33aa238da99e0d30b0"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="classEigen_1_1EulerAngles.html">EulerAngles</a>&lt; double, <a class="el" href="group__EulerAngles__Module.html#gada37f727fbc59ea1ec28d55e87079e6a">EulerSystemYZY</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__EulerAngles__Module.html#ga48505785c62a6e33aa238da99e0d30b0">EulerAnglesYZYd</a></td></tr>
<tr class="separator:ga48505785c62a6e33aa238da99e0d30b0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga04878b185127fdc80d32f7dff0ff9e14"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="classEigen_1_1EulerAngles.html">EulerAngles</a>&lt; float, <a class="el" href="group__EulerAngles__Module.html#gada37f727fbc59ea1ec28d55e87079e6a">EulerSystemYZY</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__EulerAngles__Module.html#ga04878b185127fdc80d32f7dff0ff9e14">EulerAnglesYZYf</a></td></tr>
<tr class="separator:ga04878b185127fdc80d32f7dff0ff9e14"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4fb0d195504d934ab3244d3685ff1cf1"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="classEigen_1_1EulerAngles.html">EulerAngles</a>&lt; double, <a class="el" href="group__EulerAngles__Module.html#ga9918e0f6c2f203b5a38561dede6a97c5">EulerSystemZXY</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__EulerAngles__Module.html#ga4fb0d195504d934ab3244d3685ff1cf1">EulerAnglesZXYd</a></td></tr>
<tr class="separator:ga4fb0d195504d934ab3244d3685ff1cf1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2d7e6ab44093ec3db57e3c87c55abcb2"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="classEigen_1_1EulerAngles.html">EulerAngles</a>&lt; float, <a class="el" href="group__EulerAngles__Module.html#ga9918e0f6c2f203b5a38561dede6a97c5">EulerSystemZXY</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__EulerAngles__Module.html#ga2d7e6ab44093ec3db57e3c87c55abcb2">EulerAnglesZXYf</a></td></tr>
<tr class="separator:ga2d7e6ab44093ec3db57e3c87c55abcb2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4102840115ae42675c083a2336eb7800"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="classEigen_1_1EulerAngles.html">EulerAngles</a>&lt; double, <a class="el" href="group__EulerAngles__Module.html#gafe06260e96bfa685e738112b604cd095">EulerSystemZXZ</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__EulerAngles__Module.html#ga4102840115ae42675c083a2336eb7800">EulerAnglesZXZd</a></td></tr>
<tr class="separator:ga4102840115ae42675c083a2336eb7800"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac5971a9807d22d26a0240189ba43bdcb"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="classEigen_1_1EulerAngles.html">EulerAngles</a>&lt; float, <a class="el" href="group__EulerAngles__Module.html#gafe06260e96bfa685e738112b604cd095">EulerSystemZXZ</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__EulerAngles__Module.html#gac5971a9807d22d26a0240189ba43bdcb">EulerAnglesZXZf</a></td></tr>
<tr class="separator:gac5971a9807d22d26a0240189ba43bdcb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4afa80019cff83df31b633b35c102cb3"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="classEigen_1_1EulerAngles.html">EulerAngles</a>&lt; double, <a class="el" href="group__EulerAngles__Module.html#gabdbee31f3c91ee6cd9b57b6866487274">EulerSystemZYX</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__EulerAngles__Module.html#ga4afa80019cff83df31b633b35c102cb3">EulerAnglesZYXd</a></td></tr>
<tr class="separator:ga4afa80019cff83df31b633b35c102cb3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga68a16f769307e750dbfac6268771f377"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="classEigen_1_1EulerAngles.html">EulerAngles</a>&lt; float, <a class="el" href="group__EulerAngles__Module.html#gabdbee31f3c91ee6cd9b57b6866487274">EulerSystemZYX</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__EulerAngles__Module.html#ga68a16f769307e750dbfac6268771f377">EulerAnglesZYXf</a></td></tr>
<tr class="separator:ga68a16f769307e750dbfac6268771f377"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad5b07931b7affb1fdb8e0a55505e2de6"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="classEigen_1_1EulerAngles.html">EulerAngles</a>&lt; double, <a class="el" href="group__EulerAngles__Module.html#ga8116a4aae51fbe002bed95a001641a8c">EulerSystemZYZ</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__EulerAngles__Module.html#gad5b07931b7affb1fdb8e0a55505e2de6">EulerAnglesZYZd</a></td></tr>
<tr class="separator:gad5b07931b7affb1fdb8e0a55505e2de6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8ad45f85baa68354f72ba9af68b6867a"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="classEigen_1_1EulerAngles.html">EulerAngles</a>&lt; float, <a class="el" href="group__EulerAngles__Module.html#ga8116a4aae51fbe002bed95a001641a8c">EulerSystemZYZ</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__EulerAngles__Module.html#ga8ad45f85baa68354f72ba9af68b6867a">EulerAnglesZYZf</a></td></tr>
<tr class="separator:ga8ad45f85baa68354f72ba9af68b6867a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf31ed290215ceddba27c304bb8537ed1"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="classEigen_1_1EulerSystem.html">EulerSystem</a>&lt; <a class="el" href="group__EulerAngles__Module.html#ggae614aa7cdd687fb5c421a54f2ce5c361a11e1ea88cbe04a6fc077475d515d0b38">EULER_X</a>, <a class="el" href="group__EulerAngles__Module.html#ggae614aa7cdd687fb5c421a54f2ce5c361aee756a2b63043248f3d83541386c266b">EULER_Y</a>, <a class="el" href="group__EulerAngles__Module.html#ggae614aa7cdd687fb5c421a54f2ce5c361a11e1ea88cbe04a6fc077475d515d0b38">EULER_X</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__EulerAngles__Module.html#gaf31ed290215ceddba27c304bb8537ed1">EulerSystemXYX</a></td></tr>
<tr class="separator:gaf31ed290215ceddba27c304bb8537ed1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7c4d42543380af953bfc009fa012d8a6"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="classEigen_1_1EulerSystem.html">EulerSystem</a>&lt; <a class="el" href="group__EulerAngles__Module.html#ggae614aa7cdd687fb5c421a54f2ce5c361a11e1ea88cbe04a6fc077475d515d0b38">EULER_X</a>, <a class="el" href="group__EulerAngles__Module.html#ggae614aa7cdd687fb5c421a54f2ce5c361aee756a2b63043248f3d83541386c266b">EULER_Y</a>, <a class="el" href="group__EulerAngles__Module.html#ggae614aa7cdd687fb5c421a54f2ce5c361a95187b9943820cca5edc4bc96b3c08be">EULER_Z</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__EulerAngles__Module.html#ga7c4d42543380af953bfc009fa012d8a6">EulerSystemXYZ</a></td></tr>
<tr class="separator:ga7c4d42543380af953bfc009fa012d8a6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0080bc8af60feb746663bd83e930b39e"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="classEigen_1_1EulerSystem.html">EulerSystem</a>&lt; <a class="el" href="group__EulerAngles__Module.html#ggae614aa7cdd687fb5c421a54f2ce5c361a11e1ea88cbe04a6fc077475d515d0b38">EULER_X</a>, <a class="el" href="group__EulerAngles__Module.html#ggae614aa7cdd687fb5c421a54f2ce5c361a95187b9943820cca5edc4bc96b3c08be">EULER_Z</a>, <a class="el" href="group__EulerAngles__Module.html#ggae614aa7cdd687fb5c421a54f2ce5c361a11e1ea88cbe04a6fc077475d515d0b38">EULER_X</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__EulerAngles__Module.html#ga0080bc8af60feb746663bd83e930b39e">EulerSystemXZX</a></td></tr>
<tr class="separator:ga0080bc8af60feb746663bd83e930b39e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga35f001d8aeef43d6a3d661c6e70dd762"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="classEigen_1_1EulerSystem.html">EulerSystem</a>&lt; <a class="el" href="group__EulerAngles__Module.html#ggae614aa7cdd687fb5c421a54f2ce5c361a11e1ea88cbe04a6fc077475d515d0b38">EULER_X</a>, <a class="el" href="group__EulerAngles__Module.html#ggae614aa7cdd687fb5c421a54f2ce5c361a95187b9943820cca5edc4bc96b3c08be">EULER_Z</a>, <a class="el" href="group__EulerAngles__Module.html#ggae614aa7cdd687fb5c421a54f2ce5c361aee756a2b63043248f3d83541386c266b">EULER_Y</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__EulerAngles__Module.html#ga35f001d8aeef43d6a3d661c6e70dd762">EulerSystemXZY</a></td></tr>
<tr class="separator:ga35f001d8aeef43d6a3d661c6e70dd762"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabeaefca8d5f5f9ddeac746b3ba3945fa"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="classEigen_1_1EulerSystem.html">EulerSystem</a>&lt; <a class="el" href="group__EulerAngles__Module.html#ggae614aa7cdd687fb5c421a54f2ce5c361aee756a2b63043248f3d83541386c266b">EULER_Y</a>, <a class="el" href="group__EulerAngles__Module.html#ggae614aa7cdd687fb5c421a54f2ce5c361a11e1ea88cbe04a6fc077475d515d0b38">EULER_X</a>, <a class="el" href="group__EulerAngles__Module.html#ggae614aa7cdd687fb5c421a54f2ce5c361aee756a2b63043248f3d83541386c266b">EULER_Y</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__EulerAngles__Module.html#gabeaefca8d5f5f9ddeac746b3ba3945fa">EulerSystemYXY</a></td></tr>
<tr class="separator:gabeaefca8d5f5f9ddeac746b3ba3945fa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac043703434ad0ccdb513953b1393df8f"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="classEigen_1_1EulerSystem.html">EulerSystem</a>&lt; <a class="el" href="group__EulerAngles__Module.html#ggae614aa7cdd687fb5c421a54f2ce5c361aee756a2b63043248f3d83541386c266b">EULER_Y</a>, <a class="el" href="group__EulerAngles__Module.html#ggae614aa7cdd687fb5c421a54f2ce5c361a11e1ea88cbe04a6fc077475d515d0b38">EULER_X</a>, <a class="el" href="group__EulerAngles__Module.html#ggae614aa7cdd687fb5c421a54f2ce5c361a95187b9943820cca5edc4bc96b3c08be">EULER_Z</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__EulerAngles__Module.html#gac043703434ad0ccdb513953b1393df8f">EulerSystemYXZ</a></td></tr>
<tr class="separator:gac043703434ad0ccdb513953b1393df8f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3a02c9a9ed8ae8286b003246064e7ddd"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="classEigen_1_1EulerSystem.html">EulerSystem</a>&lt; <a class="el" href="group__EulerAngles__Module.html#ggae614aa7cdd687fb5c421a54f2ce5c361aee756a2b63043248f3d83541386c266b">EULER_Y</a>, <a class="el" href="group__EulerAngles__Module.html#ggae614aa7cdd687fb5c421a54f2ce5c361a95187b9943820cca5edc4bc96b3c08be">EULER_Z</a>, <a class="el" href="group__EulerAngles__Module.html#ggae614aa7cdd687fb5c421a54f2ce5c361a11e1ea88cbe04a6fc077475d515d0b38">EULER_X</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__EulerAngles__Module.html#ga3a02c9a9ed8ae8286b003246064e7ddd">EulerSystemYZX</a></td></tr>
<tr class="separator:ga3a02c9a9ed8ae8286b003246064e7ddd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gada37f727fbc59ea1ec28d55e87079e6a"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="classEigen_1_1EulerSystem.html">EulerSystem</a>&lt; <a class="el" href="group__EulerAngles__Module.html#ggae614aa7cdd687fb5c421a54f2ce5c361aee756a2b63043248f3d83541386c266b">EULER_Y</a>, <a class="el" href="group__EulerAngles__Module.html#ggae614aa7cdd687fb5c421a54f2ce5c361a95187b9943820cca5edc4bc96b3c08be">EULER_Z</a>, <a class="el" href="group__EulerAngles__Module.html#ggae614aa7cdd687fb5c421a54f2ce5c361aee756a2b63043248f3d83541386c266b">EULER_Y</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__EulerAngles__Module.html#gada37f727fbc59ea1ec28d55e87079e6a">EulerSystemYZY</a></td></tr>
<tr class="separator:gada37f727fbc59ea1ec28d55e87079e6a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9918e0f6c2f203b5a38561dede6a97c5"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="classEigen_1_1EulerSystem.html">EulerSystem</a>&lt; <a class="el" href="group__EulerAngles__Module.html#ggae614aa7cdd687fb5c421a54f2ce5c361a95187b9943820cca5edc4bc96b3c08be">EULER_Z</a>, <a class="el" href="group__EulerAngles__Module.html#ggae614aa7cdd687fb5c421a54f2ce5c361a11e1ea88cbe04a6fc077475d515d0b38">EULER_X</a>, <a class="el" href="group__EulerAngles__Module.html#ggae614aa7cdd687fb5c421a54f2ce5c361aee756a2b63043248f3d83541386c266b">EULER_Y</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__EulerAngles__Module.html#ga9918e0f6c2f203b5a38561dede6a97c5">EulerSystemZXY</a></td></tr>
<tr class="separator:ga9918e0f6c2f203b5a38561dede6a97c5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafe06260e96bfa685e738112b604cd095"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="classEigen_1_1EulerSystem.html">EulerSystem</a>&lt; <a class="el" href="group__EulerAngles__Module.html#ggae614aa7cdd687fb5c421a54f2ce5c361a95187b9943820cca5edc4bc96b3c08be">EULER_Z</a>, <a class="el" href="group__EulerAngles__Module.html#ggae614aa7cdd687fb5c421a54f2ce5c361a11e1ea88cbe04a6fc077475d515d0b38">EULER_X</a>, <a class="el" href="group__EulerAngles__Module.html#ggae614aa7cdd687fb5c421a54f2ce5c361a95187b9943820cca5edc4bc96b3c08be">EULER_Z</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__EulerAngles__Module.html#gafe06260e96bfa685e738112b604cd095">EulerSystemZXZ</a></td></tr>
<tr class="separator:gafe06260e96bfa685e738112b604cd095"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabdbee31f3c91ee6cd9b57b6866487274"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="classEigen_1_1EulerSystem.html">EulerSystem</a>&lt; <a class="el" href="group__EulerAngles__Module.html#ggae614aa7cdd687fb5c421a54f2ce5c361a95187b9943820cca5edc4bc96b3c08be">EULER_Z</a>, <a class="el" href="group__EulerAngles__Module.html#ggae614aa7cdd687fb5c421a54f2ce5c361aee756a2b63043248f3d83541386c266b">EULER_Y</a>, <a class="el" href="group__EulerAngles__Module.html#ggae614aa7cdd687fb5c421a54f2ce5c361a11e1ea88cbe04a6fc077475d515d0b38">EULER_X</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__EulerAngles__Module.html#gabdbee31f3c91ee6cd9b57b6866487274">EulerSystemZYX</a></td></tr>
<tr class="separator:gabdbee31f3c91ee6cd9b57b6866487274"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8116a4aae51fbe002bed95a001641a8c"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="classEigen_1_1EulerSystem.html">EulerSystem</a>&lt; <a class="el" href="group__EulerAngles__Module.html#ggae614aa7cdd687fb5c421a54f2ce5c361a95187b9943820cca5edc4bc96b3c08be">EULER_Z</a>, <a class="el" href="group__EulerAngles__Module.html#ggae614aa7cdd687fb5c421a54f2ce5c361aee756a2b63043248f3d83541386c266b">EULER_Y</a>, <a class="el" href="group__EulerAngles__Module.html#ggae614aa7cdd687fb5c421a54f2ce5c361a95187b9943820cca5edc4bc96b3c08be">EULER_Z</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__EulerAngles__Module.html#ga8116a4aae51fbe002bed95a001641a8c">EulerSystemZYZ</a></td></tr>
<tr class="separator:ga8116a4aae51fbe002bed95a001641a8c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa04df76fa4fc7d93538c28bbbd838507"><td class="memItemLeft" align="right" valign="top"><a id="aa04df76fa4fc7d93538c28bbbd838507"></a>
typedef <a class="el" href="classEigen_1_1Spline.html">Spline</a>&lt; double, 2 &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceEigen.html#aa04df76fa4fc7d93538c28bbbd838507">Spline2d</a></td></tr>
<tr class="memdesc:aa04df76fa4fc7d93538c28bbbd838507"><td class="mdescLeft">&#160;</td><td class="mdescRight">2D double B-spline with dynamic degree. <br /></td></tr>
<tr class="separator:aa04df76fa4fc7d93538c28bbbd838507"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1709ceddcb1e899317ac4bdb9682807f"><td class="memItemLeft" align="right" valign="top"><a id="a1709ceddcb1e899317ac4bdb9682807f"></a>
typedef <a class="el" href="classEigen_1_1Spline.html">Spline</a>&lt; float, 2 &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceEigen.html#a1709ceddcb1e899317ac4bdb9682807f">Spline2f</a></td></tr>
<tr class="memdesc:a1709ceddcb1e899317ac4bdb9682807f"><td class="mdescLeft">&#160;</td><td class="mdescRight">2D float B-spline with dynamic degree. <br /></td></tr>
<tr class="separator:a1709ceddcb1e899317ac4bdb9682807f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a34dfede40d5b8f3b2443ff20d891f455"><td class="memItemLeft" align="right" valign="top"><a id="a34dfede40d5b8f3b2443ff20d891f455"></a>
typedef <a class="el" href="classEigen_1_1Spline.html">Spline</a>&lt; double, 3 &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceEigen.html#a34dfede40d5b8f3b2443ff20d891f455">Spline3d</a></td></tr>
<tr class="memdesc:a34dfede40d5b8f3b2443ff20d891f455"><td class="mdescLeft">&#160;</td><td class="mdescRight">3D double B-spline with dynamic degree. <br /></td></tr>
<tr class="separator:a34dfede40d5b8f3b2443ff20d891f455"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a612e989f65acc6abc1593909f901e455"><td class="memItemLeft" align="right" valign="top"><a id="a612e989f65acc6abc1593909f901e455"></a>
typedef <a class="el" href="classEigen_1_1Spline.html">Spline</a>&lt; float, 3 &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceEigen.html#a612e989f65acc6abc1593909f901e455">Spline3f</a></td></tr>
<tr class="memdesc:a612e989f65acc6abc1593909f901e455"><td class="mdescLeft">&#160;</td><td class="mdescRight">3D float B-spline with dynamic degree. <br /></td></tr>
<tr class="separator:a612e989f65acc6abc1593909f901e455"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="enum-members"></a>
Enumerations</h2></td></tr>
<tr class="memitem:gae614aa7cdd687fb5c421a54f2ce5c361"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__EulerAngles__Module.html#gae614aa7cdd687fb5c421a54f2ce5c361">EulerAxis</a> { <br />
&#160;&#160;<a class="el" href="group__EulerAngles__Module.html#ggae614aa7cdd687fb5c421a54f2ce5c361a11e1ea88cbe04a6fc077475d515d0b38">EULER_X</a>, 
<br />
&#160;&#160;<a class="el" href="group__EulerAngles__Module.html#ggae614aa7cdd687fb5c421a54f2ce5c361aee756a2b63043248f3d83541386c266b">EULER_Y</a>, 
<br />
&#160;&#160;<a class="el" href="group__EulerAngles__Module.html#ggae614aa7cdd687fb5c421a54f2ce5c361a95187b9943820cca5edc4bc96b3c08be">EULER_Z</a>
<br />
 }<tr class="memdesc:gae614aa7cdd687fb5c421a54f2ce5c361"><td class="mdescLeft">&#160;</td><td class="mdescRight">Representation of a fixed signed rotation axis for EulerSystem.  <a href="group__EulerAngles__Module.html#gae614aa7cdd687fb5c421a54f2ce5c361">More...</a><br /></td></tr>
</td></tr>
<tr class="separator:gae614aa7cdd687fb5c421a54f2ce5c361"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a6d7e9b581a1fc3ca3c8aff6a0a69f523"><td class="memTemplParams" colspan="2">template&lt;typename ADerived , typename BDerived , typename XDerived &gt; </td></tr>
<tr class="memitem:a6d7e9b581a1fc3ca3c8aff6a0a69f523"><td class="memTemplItemLeft" align="right" valign="top">const TensorCwiseTernaryOp&lt; internal::scalar_betainc_op&lt; typename XDerived::Scalar &gt;, const ADerived, const BDerived, const XDerived &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceEigen.html#a6d7e9b581a1fc3ca3c8aff6a0a69f523">betainc</a> (const ADerived &amp;a, const BDerived &amp;b, const XDerived &amp;x)</td></tr>
<tr class="separator:a6d7e9b581a1fc3ca3c8aff6a0a69f523"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac58db11132cd34e57ad819f3e77ff60c"><td class="memTemplParams" colspan="2">template&lt;typename ArgADerived , typename ArgBDerived , typename ArgXDerived &gt; </td></tr>
<tr class="memitem:ac58db11132cd34e57ad819f3e77ff60c"><td class="memTemplItemLeft" align="right" valign="top">const Eigen::CwiseTernaryOp&lt; Eigen::internal::scalar_betainc_op&lt; typename ArgXDerived::Scalar &gt;, const ArgADerived, const ArgBDerived, const ArgXDerived &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceEigen.html#ac58db11132cd34e57ad819f3e77ff60c">betainc</a> (const Eigen::ArrayBase&lt; ArgADerived &gt; &amp;a, const Eigen::ArrayBase&lt; ArgBDerived &gt; &amp;b, const Eigen::ArrayBase&lt; ArgXDerived &gt; &amp;x)</td></tr>
<tr class="separator:ac58db11132cd34e57ad819f3e77ff60c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a07d8e283f082c972338f3fc4f644b2a9"><td class="memTemplParams" colspan="2">template&lt;typename BVH , typename Intersector &gt; </td></tr>
<tr class="memitem:a07d8e283f082c972338f3fc4f644b2a9"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceEigen.html#a07d8e283f082c972338f3fc4f644b2a9">BVIntersect</a> (const BVH &amp;tree, Intersector &amp;intersector)</td></tr>
<tr class="separator:a07d8e283f082c972338f3fc4f644b2a9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac3b8047a3ee05b5e6fec4668197a9a43"><td class="memTemplParams" colspan="2">template&lt;typename BVH1 , typename BVH2 , typename Intersector &gt; </td></tr>
<tr class="memitem:ac3b8047a3ee05b5e6fec4668197a9a43"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceEigen.html#ac3b8047a3ee05b5e6fec4668197a9a43">BVIntersect</a> (const BVH1 &amp;tree1, const BVH2 &amp;tree2, Intersector &amp;intersector)</td></tr>
<tr class="separator:ac3b8047a3ee05b5e6fec4668197a9a43"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adcbe73ac1482eacab0e18ee32c25508e"><td class="memTemplParams" colspan="2">template&lt;typename BVH , typename Minimizer &gt; </td></tr>
<tr class="memitem:adcbe73ac1482eacab0e18ee32c25508e"><td class="memTemplItemLeft" align="right" valign="top">Minimizer::Scalar&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceEigen.html#adcbe73ac1482eacab0e18ee32c25508e">BVMinimize</a> (const BVH &amp;tree, Minimizer &amp;minimizer)</td></tr>
<tr class="separator:adcbe73ac1482eacab0e18ee32c25508e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a915f6adc8b195c94a83c35de6a842556"><td class="memTemplParams" colspan="2">template&lt;typename BVH1 , typename BVH2 , typename Minimizer &gt; </td></tr>
<tr class="memitem:a915f6adc8b195c94a83c35de6a842556"><td class="memTemplItemLeft" align="right" valign="top">Minimizer::Scalar&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceEigen.html#a915f6adc8b195c94a83c35de6a842556">BVMinimize</a> (const BVH1 &amp;tree1, const BVH2 &amp;tree2, Minimizer &amp;minimizer)</td></tr>
<tr class="separator:a915f6adc8b195c94a83c35de6a842556"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga375e3ea1f370fb76dfe0f43a89b95926"><td class="memTemplParams" colspan="2">template&lt;typename Polynomial &gt; </td></tr>
<tr class="memitem:ga375e3ea1f370fb76dfe0f43a89b95926"><td class="memTemplItemLeft" align="right" valign="top">NumTraits&lt; typename Polynomial::Scalar &gt;::Real&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__Polynomials__Module.html#ga375e3ea1f370fb76dfe0f43a89b95926">cauchy_max_bound</a> (const Polynomial &amp;poly)</td></tr>
<tr class="separator:ga375e3ea1f370fb76dfe0f43a89b95926"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab076afbdba0e9298a541cc4e8cc7506b"><td class="memTemplParams" colspan="2">template&lt;typename Polynomial &gt; </td></tr>
<tr class="memitem:gab076afbdba0e9298a541cc4e8cc7506b"><td class="memTemplItemLeft" align="right" valign="top">NumTraits&lt; typename Polynomial::Scalar &gt;::Real&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__Polynomials__Module.html#gab076afbdba0e9298a541cc4e8cc7506b">cauchy_min_bound</a> (const Polynomial &amp;poly)</td></tr>
<tr class="separator:gab076afbdba0e9298a541cc4e8cc7506b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1b4cbde5d98411405871accf877552d2"><td class="memTemplParams" colspan="2">template&lt;typename PointArrayType , typename KnotVectorType &gt; </td></tr>
<tr class="memitem:ga1b4cbde5d98411405871accf877552d2"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__Splines__Module.html#ga1b4cbde5d98411405871accf877552d2">ChordLengths</a> (const PointArrayType &amp;pts, KnotVectorType &amp;chord_lengths)</td></tr>
<tr class="memdesc:ga1b4cbde5d98411405871accf877552d2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes chord length parameters which are required for spline interpolation.  <a href="group__Splines__Module.html#ga1b4cbde5d98411405871accf877552d2">More...</a><br /></td></tr>
<tr class="separator:ga1b4cbde5d98411405871accf877552d2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6e89509c5ff1af076baea462520f231c"><td class="memTemplParams" colspan="2">template&lt;typename Derived , typename ExponentDerived &gt; </td></tr>
<tr class="memitem:a6e89509c5ff1af076baea462520f231c"><td class="memTemplItemLeft" align="right" valign="top">const Eigen::CwiseBinaryOp&lt; Eigen::internal::scalar_igamma_op&lt; typename Derived::Scalar &gt;, const Derived, const ExponentDerived &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceEigen.html#a6e89509c5ff1af076baea462520f231c">igamma</a> (const Eigen::ArrayBase&lt; Derived &gt; &amp;a, const Eigen::ArrayBase&lt; ExponentDerived &gt; &amp;x)</td></tr>
<tr class="separator:a6e89509c5ff1af076baea462520f231c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2b1593c0c3f9d1673ae5980ae03e75f1"><td class="memTemplParams" colspan="2">template&lt;typename Derived , typename ExponentDerived &gt; </td></tr>
<tr class="memitem:a2b1593c0c3f9d1673ae5980ae03e75f1"><td class="memTemplItemLeft" align="right" valign="top">const Eigen::CwiseBinaryOp&lt; Eigen::internal::scalar_igammac_op&lt; typename Derived::Scalar &gt;, const Derived, const ExponentDerived &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceEigen.html#a2b1593c0c3f9d1673ae5980ae03e75f1">igammac</a> (const Eigen::ArrayBase&lt; Derived &gt; &amp;a, const Eigen::ArrayBase&lt; ExponentDerived &gt; &amp;x)</td></tr>
<tr class="separator:a2b1593c0c3f9d1673ae5980ae03e75f1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9474da5ed68bbd9a6788a999330416d6"><td class="memTemplParams" colspan="2">template&lt;typename KnotVectorType &gt; </td></tr>
<tr class="memitem:ga9474da5ed68bbd9a6788a999330416d6"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__Splines__Module.html#ga9474da5ed68bbd9a6788a999330416d6">KnotAveraging</a> (const KnotVectorType &amp;parameters, DenseIndex degree, KnotVectorType &amp;knots)</td></tr>
<tr class="memdesc:ga9474da5ed68bbd9a6788a999330416d6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes knot averages.The knots are computed as </p><p class="formulaDsp">
<img class="formulaDsp" alt="\begin{align*} u_0 &amp; = \hdots = u_p = 0 \\ u_{m-p} &amp; = \hdots = u_{m} = 1 \\ u_{j+p} &amp; = \frac{1}{p}\sum_{i=j}^{j+p-1}\bar{u}_i \quad\quad j=1,\hdots,n-p \end{align*}" src="form_98.png"/>
</p>
<p> where <img class="formulaInl" alt="$p$" src="form_95.png"/> is the degree and <img class="formulaInl" alt="$m+1$" src="form_99.png"/> the number knots of the desired interpolating spline.  <a href="group__Splines__Module.html#ga9474da5ed68bbd9a6788a999330416d6">More...</a><br /></td></tr>
<tr class="separator:ga9474da5ed68bbd9a6788a999330416d6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae10a6f9b6ab7fb400a2526b6382c533b"><td class="memTemplParams" colspan="2">template&lt;typename KnotVectorType , typename ParameterVectorType , typename IndexArray &gt; </td></tr>
<tr class="memitem:gae10a6f9b6ab7fb400a2526b6382c533b"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__Splines__Module.html#gae10a6f9b6ab7fb400a2526b6382c533b">KnotAveragingWithDerivatives</a> (const ParameterVectorType &amp;parameters, const unsigned int degree, const IndexArray &amp;derivativeIndices, KnotVectorType &amp;knots)</td></tr>
<tr class="memdesc:gae10a6f9b6ab7fb400a2526b6382c533b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes knot averages when derivative constraints are present. Note that this is a technical interpretation of the referenced article since the algorithm contained therein is incorrect as written.  <a href="group__Splines__Module.html#gae10a6f9b6ab7fb400a2526b6382c533b">More...</a><br /></td></tr>
<tr class="separator:gae10a6f9b6ab7fb400a2526b6382c533b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa8924dffc6cee7aa1e908dc395a7a167"><td class="memTemplParams" colspan="2">template&lt;typename A , typename B &gt; </td></tr>
<tr class="memitem:gaa8924dffc6cee7aa1e908dc395a7a167"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classEigen_1_1KroneckerProduct.html">KroneckerProduct</a>&lt; A, B &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__KroneckerProduct__Module.html#gaa8924dffc6cee7aa1e908dc395a7a167">kroneckerProduct</a> (const MatrixBase&lt; A &gt; &amp;a, const MatrixBase&lt; B &gt; &amp;b)</td></tr>
<tr class="separator:gaa8924dffc6cee7aa1e908dc395a7a167"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaca497f43cc92bcbf6eaff64984a266cc"><td class="memTemplParams" colspan="2">template&lt;typename A , typename B &gt; </td></tr>
<tr class="memitem:gaca497f43cc92bcbf6eaff64984a266cc"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classEigen_1_1KroneckerProductSparse.html">KroneckerProductSparse</a>&lt; A, B &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__KroneckerProduct__Module.html#gaca497f43cc92bcbf6eaff64984a266cc">kroneckerProduct</a> (const EigenBase&lt; A &gt; &amp;a, const EigenBase&lt; B &gt; &amp;b)</td></tr>
<tr class="separator:gaca497f43cc92bcbf6eaff64984a266cc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2f490197e16df831683018e383e29346"><td class="memTemplParams" colspan="2">template&lt;typename MatrixType , typename ResultType &gt; </td></tr>
<tr class="memitem:ga2f490197e16df831683018e383e29346"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__MatrixFunctions__Module.html#ga2f490197e16df831683018e383e29346">matrix_sqrt_quasi_triangular</a> (const MatrixType &amp;arg, ResultType &amp;result)</td></tr>
<tr class="memdesc:ga2f490197e16df831683018e383e29346"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute matrix square root of quasi-triangular matrix.  <a href="group__MatrixFunctions__Module.html#ga2f490197e16df831683018e383e29346">More...</a><br /></td></tr>
<tr class="separator:ga2f490197e16df831683018e383e29346"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae51c91f920f6ea4a7f6f72caa1e8249f"><td class="memTemplParams" colspan="2">template&lt;typename MatrixType , typename ResultType &gt; </td></tr>
<tr class="memitem:gae51c91f920f6ea4a7f6f72caa1e8249f"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__MatrixFunctions__Module.html#gae51c91f920f6ea4a7f6f72caa1e8249f">matrix_sqrt_triangular</a> (const MatrixType &amp;arg, ResultType &amp;result)</td></tr>
<tr class="memdesc:gae51c91f920f6ea4a7f6f72caa1e8249f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute matrix square root of triangular matrix.  <a href="group__MatrixFunctions__Module.html#gae51c91f920f6ea4a7f6f72caa1e8249f">More...</a><br /></td></tr>
<tr class="separator:gae51c91f920f6ea4a7f6f72caa1e8249f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadb64ffddaa9e83634e3ab0e3fd3664f5"><td class="memTemplParams" colspan="2">template&lt;typename Polynomials , typename T &gt; </td></tr>
<tr class="memitem:gadb64ffddaa9e83634e3ab0e3fd3664f5"><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__Polynomials__Module.html#gadb64ffddaa9e83634e3ab0e3fd3664f5">poly_eval</a> (const Polynomials &amp;poly, const T &amp;x)</td></tr>
<tr class="separator:gadb64ffddaa9e83634e3ab0e3fd3664f5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaadbf059bc28ce1cf94c57c1454633d40"><td class="memTemplParams" colspan="2">template&lt;typename Polynomials , typename T &gt; </td></tr>
<tr class="memitem:gaadbf059bc28ce1cf94c57c1454633d40"><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__Polynomials__Module.html#gaadbf059bc28ce1cf94c57c1454633d40">poly_eval_horner</a> (const Polynomials &amp;poly, const T &amp;x)</td></tr>
<tr class="separator:gaadbf059bc28ce1cf94c57c1454633d40"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7ec2455c3a3bb4b0c1401b25a8480361"><td class="memTemplParams" colspan="2">template&lt;typename DerivedN , typename DerivedX &gt; </td></tr>
<tr class="memitem:a7ec2455c3a3bb4b0c1401b25a8480361"><td class="memTemplItemLeft" align="right" valign="top">const Eigen::CwiseBinaryOp&lt; Eigen::internal::scalar_polygamma_op&lt; typename DerivedX::Scalar &gt;, const DerivedN, const DerivedX &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceEigen.html#a7ec2455c3a3bb4b0c1401b25a8480361">polygamma</a> (const Eigen::ArrayBase&lt; DerivedN &gt; &amp;n, const Eigen::ArrayBase&lt; DerivedX &gt; &amp;x)</td></tr>
<tr class="separator:a7ec2455c3a3bb4b0c1401b25a8480361"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafbc3648f7ef67db3d5d04454fc1257fd"><td class="memTemplParams" colspan="2">template&lt;typename RootVector , typename Polynomial &gt; </td></tr>
<tr class="memitem:gafbc3648f7ef67db3d5d04454fc1257fd"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__Polynomials__Module.html#gafbc3648f7ef67db3d5d04454fc1257fd">roots_to_monicPolynomial</a> (const RootVector &amp;rv, Polynomial &amp;poly)</td></tr>
<tr class="separator:gafbc3648f7ef67db3d5d04454fc1257fd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ade7c45ba55113cf0c89e33972f3da434"><td class="memTemplParams" colspan="2">template&lt;typename DerivedX , typename DerivedQ &gt; </td></tr>
<tr class="memitem:ade7c45ba55113cf0c89e33972f3da434"><td class="memTemplItemLeft" align="right" valign="top">const Eigen::CwiseBinaryOp&lt; Eigen::internal::scalar_zeta_op&lt; typename DerivedX::Scalar &gt;, const DerivedX, const DerivedQ &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceEigen.html#ade7c45ba55113cf0c89e33972f3da434">zeta</a> (const Eigen::ArrayBase&lt; DerivedX &gt; &amp;x, const Eigen::ArrayBase&lt; DerivedQ &gt; &amp;q)</td></tr>
<tr class="separator:ade7c45ba55113cf0c89e33972f3da434"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Namespace containing all symbols from the Eigen library. </p>
</div><h2 class="groupheader">Function Documentation</h2>
<a id="a6d7e9b581a1fc3ca3c8aff6a0a69f523"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6d7e9b581a1fc3ca3c8aff6a0a69f523">&#9670;&nbsp;</a></span>betainc() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ADerived , typename BDerived , typename XDerived &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const TensorCwiseTernaryOp&lt;internal::scalar_betainc_op&lt;typename XDerived::Scalar&gt;, const ADerived, const BDerived, const XDerived&gt; Eigen::betainc </td>
          <td>(</td>
          <td class="paramtype">const ADerived &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const BDerived &amp;&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const XDerived &amp;&#160;</td>
          <td class="paramname"><em>x</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p><span class="cpp11">[c++11]</span> </p><dl class="section return"><dt>Returns</dt><dd>an expression of the coefficient-wise betainc(<em>x</em>, <em>a</em>, <em>b</em>) to the given tensors.</dd></dl>
<p>This function computes the regularized incomplete beta function (integral). </p>

</div>
</div>
<a id="ac58db11132cd34e57ad819f3e77ff60c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac58db11132cd34e57ad819f3e77ff60c">&#9670;&nbsp;</a></span>betainc() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ArgADerived , typename ArgBDerived , typename ArgXDerived &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const Eigen::CwiseTernaryOp&lt;Eigen::internal::scalar_betainc_op&lt;typename ArgXDerived::Scalar&gt;, const ArgADerived, const ArgBDerived, const ArgXDerived&gt; Eigen::betainc </td>
          <td>(</td>
          <td class="paramtype">const Eigen::ArrayBase&lt; ArgADerived &gt; &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::ArrayBase&lt; ArgBDerived &gt; &amp;&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::ArrayBase&lt; ArgXDerived &gt; &amp;&#160;</td>
          <td class="paramname"><em>x</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p><span class="cpp11">[c++11]</span> </p><dl class="section return"><dt>Returns</dt><dd>an expression of the coefficient-wise betainc(<em>x</em>, <em>a</em>, <em>b</em>) to the given arrays.</dd></dl>
<p>This function computes the regularized incomplete beta function (integral).</p>
<dl class="section note"><dt>Note</dt><dd>This function supports only float and double scalar types in c++11 mode. To support other scalar types, or float/double in non c++11 mode, the user has to provide implementations of betainc(T,T,T) for any scalar type T to be supported.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="namespaceEigen.html#a6d7e9b581a1fc3ca3c8aff6a0a69f523">Eigen::betainc()</a>, Eigen::lgamma() </dd></dl>

</div>
</div>
<a id="a07d8e283f082c972338f3fc4f644b2a9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a07d8e283f082c972338f3fc4f644b2a9">&#9670;&nbsp;</a></span>BVIntersect() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename BVH , typename Intersector &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void Eigen::BVIntersect </td>
          <td>(</td>
          <td class="paramtype">const BVH &amp;&#160;</td>
          <td class="paramname"><em>tree</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Intersector &amp;&#160;</td>
          <td class="paramname"><em>intersector</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Given a BVH, runs the query encapsulated by <em>intersector</em>. The Intersector type must provide the following members:</p><div class="fragment"><div class="line"><span class="keywordtype">bool</span> intersectVolume(<span class="keyword">const</span> BVH::Volume &amp;volume) <span class="comment">//returns true if volume intersects the query</span></div><div class="line"><span class="keywordtype">bool</span> intersectObject(<span class="keyword">const</span> BVH::Object &amp;<span class="keywordtype">object</span>) <span class="comment">//returns true if the search should terminate immediately</span></div></div><!-- fragment --> 
</div>
</div>
<a id="ac3b8047a3ee05b5e6fec4668197a9a43"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac3b8047a3ee05b5e6fec4668197a9a43">&#9670;&nbsp;</a></span>BVIntersect() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename BVH1 , typename BVH2 , typename Intersector &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void Eigen::BVIntersect </td>
          <td>(</td>
          <td class="paramtype">const BVH1 &amp;&#160;</td>
          <td class="paramname"><em>tree1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const BVH2 &amp;&#160;</td>
          <td class="paramname"><em>tree2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Intersector &amp;&#160;</td>
          <td class="paramname"><em>intersector</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Given two BVH's, runs the query on their Cartesian product encapsulated by <em>intersector</em>. The Intersector type must provide the following members:</p><div class="fragment"><div class="line"><span class="keywordtype">bool</span> intersectVolumeVolume(<span class="keyword">const</span> BVH1::Volume &amp;v1, <span class="keyword">const</span> BVH2::Volume &amp;v2) <span class="comment">//returns true if product of volumes intersects the query</span></div><div class="line"><span class="keywordtype">bool</span> intersectVolumeObject(<span class="keyword">const</span> BVH1::Volume &amp;v1, <span class="keyword">const</span> BVH2::Object &amp;o2) <span class="comment">//returns true if the volume-object product intersects the query</span></div><div class="line"><span class="keywordtype">bool</span> intersectObjectVolume(<span class="keyword">const</span> BVH1::Object &amp;o1, <span class="keyword">const</span> BVH2::Volume &amp;v2) <span class="comment">//returns true if the volume-object product intersects the query</span></div><div class="line"><span class="keywordtype">bool</span> intersectObjectObject(<span class="keyword">const</span> BVH1::Object &amp;o1, <span class="keyword">const</span> BVH2::Object &amp;o2) <span class="comment">//returns true if the search should terminate immediately</span></div></div><!-- fragment --> 
</div>
</div>
<a id="adcbe73ac1482eacab0e18ee32c25508e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adcbe73ac1482eacab0e18ee32c25508e">&#9670;&nbsp;</a></span>BVMinimize() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename BVH , typename Minimizer &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">Minimizer::Scalar Eigen::BVMinimize </td>
          <td>(</td>
          <td class="paramtype">const BVH &amp;&#160;</td>
          <td class="paramname"><em>tree</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Minimizer &amp;&#160;</td>
          <td class="paramname"><em>minimizer</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Given a BVH, runs the query encapsulated by <em>minimizer</em>. </p><dl class="section return"><dt>Returns</dt><dd>the minimum value. The Minimizer type must provide the following members:<div class="fragment"><div class="line"><span class="keyword">typedef</span> Scalar <span class="comment">//the numeric type of what is being minimized--not necessarily the Scalar type of the BVH (if it has one)</span></div><div class="line">Scalar minimumOnVolume(<span class="keyword">const</span> BVH::Volume &amp;volume)</div><div class="line">Scalar minimumOnObject(<span class="keyword">const</span> BVH::Object &amp;<span class="keywordtype">object</span>)</div></div><!-- fragment --> </dd></dl>

</div>
</div>
<a id="a915f6adc8b195c94a83c35de6a842556"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a915f6adc8b195c94a83c35de6a842556">&#9670;&nbsp;</a></span>BVMinimize() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename BVH1 , typename BVH2 , typename Minimizer &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">Minimizer::Scalar Eigen::BVMinimize </td>
          <td>(</td>
          <td class="paramtype">const BVH1 &amp;&#160;</td>
          <td class="paramname"><em>tree1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const BVH2 &amp;&#160;</td>
          <td class="paramname"><em>tree2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Minimizer &amp;&#160;</td>
          <td class="paramname"><em>minimizer</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Given two BVH's, runs the query on their cartesian product encapsulated by <em>minimizer</em>. </p><dl class="section return"><dt>Returns</dt><dd>the minimum value. The Minimizer type must provide the following members:<div class="fragment"><div class="line"><span class="keyword">typedef</span> Scalar <span class="comment">//the numeric type of what is being minimized--not necessarily the Scalar type of the BVH (if it has one)</span></div><div class="line">Scalar minimumOnVolumeVolume(<span class="keyword">const</span> BVH1::Volume &amp;v1, <span class="keyword">const</span> BVH2::Volume &amp;v2)</div><div class="line">Scalar minimumOnVolumeObject(<span class="keyword">const</span> BVH1::Volume &amp;v1, <span class="keyword">const</span> BVH2::Object &amp;o2)</div><div class="line">Scalar minimumOnObjectVolume(<span class="keyword">const</span> BVH1::Object &amp;o1, <span class="keyword">const</span> BVH2::Volume &amp;v2)</div><div class="line">Scalar minimumOnObjectObject(<span class="keyword">const</span> BVH1::Object &amp;o1, <span class="keyword">const</span> BVH2::Object &amp;o2)</div></div><!-- fragment --> </dd></dl>

</div>
</div>
<a id="a6e89509c5ff1af076baea462520f231c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6e89509c5ff1af076baea462520f231c">&#9670;&nbsp;</a></span>igamma()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Derived , typename ExponentDerived &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const Eigen::CwiseBinaryOp&lt;Eigen::internal::scalar_igamma_op&lt;typename Derived::Scalar&gt;, const Derived, const ExponentDerived&gt; Eigen::igamma </td>
          <td>(</td>
          <td class="paramtype">const Eigen::ArrayBase&lt; Derived &gt; &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::ArrayBase&lt; ExponentDerived &gt; &amp;&#160;</td>
          <td class="paramname"><em>x</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p><span class="cpp11">[c++11]</span> </p><dl class="section return"><dt>Returns</dt><dd>an expression of the coefficient-wise igamma(<em>a</em>, <em>x</em>) to the given arrays.</dd></dl>
<p>This function computes the coefficient-wise incomplete gamma function.</p>
<dl class="section note"><dt>Note</dt><dd>This function supports only float and double scalar types in c++11 mode. To support other scalar types, or float/double in non c++11 mode, the user has to provide implementations of igammac(T,T) for any scalar type T to be supported.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="namespaceEigen.html#a2b1593c0c3f9d1673ae5980ae03e75f1">Eigen::igammac()</a>, Eigen::lgamma() </dd></dl>

</div>
</div>
<a id="a2b1593c0c3f9d1673ae5980ae03e75f1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2b1593c0c3f9d1673ae5980ae03e75f1">&#9670;&nbsp;</a></span>igammac()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Derived , typename ExponentDerived &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const Eigen::CwiseBinaryOp&lt;Eigen::internal::scalar_igammac_op&lt;typename Derived::Scalar&gt;, const Derived, const ExponentDerived&gt; Eigen::igammac </td>
          <td>(</td>
          <td class="paramtype">const Eigen::ArrayBase&lt; Derived &gt; &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::ArrayBase&lt; ExponentDerived &gt; &amp;&#160;</td>
          <td class="paramname"><em>x</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p><span class="cpp11">[c++11]</span> </p><dl class="section return"><dt>Returns</dt><dd>an expression of the coefficient-wise igammac(<em>a</em>, <em>x</em>) to the given arrays.</dd></dl>
<p>This function computes the coefficient-wise complementary incomplete gamma function.</p>
<dl class="section note"><dt>Note</dt><dd>This function supports only float and double scalar types in c++11 mode. To support other scalar types, or float/double in non c++11 mode, the user has to provide implementations of igammac(T,T) for any scalar type T to be supported.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="namespaceEigen.html#a6e89509c5ff1af076baea462520f231c">Eigen::igamma()</a>, Eigen::lgamma() </dd></dl>

</div>
</div>
<a id="a7ec2455c3a3bb4b0c1401b25a8480361"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7ec2455c3a3bb4b0c1401b25a8480361">&#9670;&nbsp;</a></span>polygamma()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename DerivedN , typename DerivedX &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const Eigen::CwiseBinaryOp&lt;Eigen::internal::scalar_polygamma_op&lt;typename DerivedX::Scalar&gt;, const DerivedN, const DerivedX&gt; Eigen::polygamma </td>
          <td>(</td>
          <td class="paramtype">const Eigen::ArrayBase&lt; DerivedN &gt; &amp;&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::ArrayBase&lt; DerivedX &gt; &amp;&#160;</td>
          <td class="paramname"><em>x</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p><span class="cpp11">[c++11]</span> </p><dl class="section return"><dt>Returns</dt><dd>an expression of the coefficient-wise polygamma(<em>n</em>, <em>x</em>) to the given arrays.</dd></dl>
<p>It returns the <em>n</em> -th derivative of the digamma(psi) evaluated at <code>x</code>.</p>
<dl class="section note"><dt>Note</dt><dd>This function supports only float and double scalar types in c++11 mode. To support other scalar types, or float/double in non c++11 mode, the user has to provide implementations of polygamma(T,T) for any scalar type T to be supported.</dd></dl>
<dl class="section see"><dt>See also</dt><dd>Eigen::digamma() </dd></dl>

</div>
</div>
<a id="ade7c45ba55113cf0c89e33972f3da434"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ade7c45ba55113cf0c89e33972f3da434">&#9670;&nbsp;</a></span>zeta()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename DerivedX , typename DerivedQ &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const Eigen::CwiseBinaryOp&lt;Eigen::internal::scalar_zeta_op&lt;typename DerivedX::Scalar&gt;, const DerivedX, const DerivedQ&gt; Eigen::zeta </td>
          <td>(</td>
          <td class="paramtype">const Eigen::ArrayBase&lt; DerivedX &gt; &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::ArrayBase&lt; DerivedQ &gt; &amp;&#160;</td>
          <td class="paramname"><em>q</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>an expression of the coefficient-wise zeta(<em>x</em>, <em>q</em>) to the given arrays.</dd></dl>
<p>It returns the Riemann zeta function of two arguments <em>x</em> and <em>q:</em> </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>is the exposent, it must be &gt; 1 </td></tr>
    <tr><td class="paramname">q</td><td>is the shift, it must be &gt; 0</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>This function supports only float and double scalar types. To support other scalar types, the user has to provide implementations of zeta(T,T) for any scalar type T to be supported.</dd></dl>
<dl class="section see"><dt>See also</dt><dd>ArrayBase::zeta() </dd></dl>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="namespaceEigen.html">Eigen</a></li>
    <li class="footer">Generated on Mon Feb 26 2018 06:38:53 for Eigen-unsupported by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.13 </li>
  </ul>
</div>
<!-- Piwik -->
<script type="text/javascript">
var pkBaseURL = (("https:" == document.location.protocol) ? "https://stats.sylphide-consulting.com/piwik/" : "http://stats.sylphide-consulting.com/piwik/");
document.write(unescape("%3Cscript src='" + pkBaseURL + "piwik.js' type='text/javascript'%3E%3C/script%3E"));
</script><script type="text/javascript">
try {
var piwikTracker = Piwik.getTracker(pkBaseURL + "piwik.php", 20);
piwikTracker.trackPageView();
piwikTracker.enableLinkTracking();
} catch( err ) {}
</script><noscript><p><img src="http://stats.sylphide-consulting.com/piwik/piwik.php?idsite=20" style="border:0" alt="" /></p></noscript>
<!-- End Piwik Tracking Code -->
</body>
</html>
